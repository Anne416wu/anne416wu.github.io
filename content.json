{"pages":[{"title":"About","text":"BIT/CS/Junior; 2021考研; 尽管修过微机维修，仍然不掌握电脑维修技能🤥; 尽管没修过系统安装，但熟悉Linux/Win等系统重装🥴; ♥ Mickey ♥ Jay Chou ♥ Vivaldi ♥ Soft Lipa","link":"/about/index.html"},{"title":"Project","text":"","link":"/project/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"人工智能笔记","text":"北京理工大学计算机学院人工智能笔记 点击下载考试A4资料 Introduction Computational Swarm Intelligence 群体智能 蚁群算法 Nouvelle AI 行为智能 学习-变化 监督学习 非监督学习 强化学习 半监督学习* 机器学习 What Why How machines learn Defining the Learning Task 机器学习、人工神经网络（连接主义）、符号智能、行为智能 怎么防止过拟合呢？应该用cross validation，交叉比对。解释起来就是，你在你表妹那儿学到的东西，在你表姐那儿测试一下对不对。在你表姐那儿学到的，在你二姐那测试一下。来来回回用不同的测试对象和训练对象做交叉比对。这样学到规律就不会过拟合啦~ 评论里有小伙伴提到加Regularization可以解决overfit，这里也形象地说一下。还是在学习追妹子。但是我也有男人的尊严！ 有底线！不能妹子说啥就是啥！今天我的底线是，不能无限量增加要学的规矩的数量！女人不能惯着！ 所以可以引入Lasso，对规矩的数量进行一个penalize。通俗说就是，妹子你让我学三条规矩我就忍了，让我学一百条规矩大爷就不干了。这个Regularization可以有不同的形式，Lasso是一种。所以可以通过引入Regularization增加信息，帮助寻找到最优解。 人工智能机器学习概论2.1 method induction analogy deduction 2.2 type supervised learning（学校时期） 输入输出的明确对应关系 标注数据 positive/negative sample function/estimate/fitting/regression unsupervised learning（工作时期） 发现输入数据的分布规律或不同组成成分之间规律性的相互联系 结果表示形式 统计分布：数据拟合概率密度函数 数据分组：按相似程度分不同组，然后提取组的统计量 如何定义数据/数据集之间的相似性 如何执行分组计算 符号表示 概念/规则 semi-supervise learing 少量标注数据/大量未标注数据 目的：==确定未标注数据的期望输出，将其转变为标注数据== 具体途径 生成模型方法：获得与输入数据拟合的统计分布，有限混合模型（高斯混合模型） 自学习self-training：根据可靠度逐渐增加标注数据改善执行机构，再利用改善的执行机构对未标注数据标注，交替迭代进行 合作学习co-training：标注数据分未来感部分，分别训练一个不同的执行机构，利用一个执行机构为另一个执行机构从未标注数据中提取数据进行标注，从而增加另一个执行机构的训练数据并再学习 基于数据相似度：将标注数据上的标注结果香味标注数据扩散。常用图表示输入，采用最小个min cuts或随机游走random walks确定未标注数据的标注结果 reinforcement learning（幼儿时期） 给出对于输出结果正确与否的评价 2.3 优化问题 如何定义学习目标： 监督学习 实际输出与期望输出间误差最小化 非监督聚类 数据到聚类中心距离最小化 强化学习 希望累计收益最大化 如何执行优化计算：搜索/最优化问题 2.4其他学习概念 生成学习generative 和判别学习discriminative 度量学习 在线学习/递增学习 反馈学习 多任务学习 深度学习 迁移学习 流形学习 多示例学习 2.5 对学习算法的评价 过学习与泛化 过学习Overfitting 对经验数据之外的数据性能下降 执行机构不是越复杂越好，复杂会使其局限于训练数据 ==奥坎姆剃刀处理原则–提高经验数据处理精度，降低执行机构的复杂度 “如无必要，勿增实体”== 偏置bias 选择有偏算法多于无偏算法（没意义） 计算量小 泛化能力强 绝对偏置：结果被限制在某个特定范围 相对偏置：部分学习结果相对其他结果有优先权 有些偏置在设计学习算法时明确给出，比如函数类型、统计分布形式 分析方法 分多个数据集，比较各自学习结果的均质和方差 偏差大，绝对偏置不恰当 方差小，偏置强，好 数据鲁棒性robustness 训练数据的规模 训练数据的变化：来自同一问题的不同数据，算法保证学习结果一致 数据噪声 数据不平衡：重复采样、减少采样、忽视数据量的数据类型 计算复杂性 computatin complexity） 程序，时间和空间复杂度 多项式级算法-满足的算法 指数级算法 可伸缩性 收敛性和收敛速率 局部最优 local optimization 透明性（可解释性）-外部人员能否理解 监督学习 函数形式 数据点形式 离散函数形式 连续函数形式 随机函数形式 学习方法案例 记忆学习 决策树学习 支持向量机 贝叶斯学习 3.1 函数形式 显式表示形式 基函数 basis function加权求和表达目标函数 $y=\\sum^k_{i=1}k_iB_i(x)$ 隐式表示形式 图结构 决策树3.4 贝叶斯信念网3.8 神经网络10.1 数据点表示形式 模式识别 最近邻 k-近邻：对于未见数据，根据其到类别样例的距离来进行分类 3.2 优化目标 优化目标/准则 optimization objective/criterion，神经网络中成为损失loss 经验风险最小化 最小平方误差 最小化熵 信息熵 entropy $H(c)=\\sum^k_{k=1}-P(c_k)\\log P(C_k)$ 值愈小愈确定 实质是$-log P(C_k)$的均值 交叉熵 $CE=-(\\sum^N_{i=1}\\sum^K_{k=1}P^k_d(x_i)+(1-P^k_d(x_i))\\log (a-P^k_y(x_i)))$ 互信息 conditional entropy optimization algorithm 3.3 记忆学习 rote learning 存储结构 环境稳定性 记忆与计算的平衡 3.4 决策树学习 生成决策树–自顶向下 贪婪 ID3 overfitting 提前停止pre-pruning 提前限定树的深度 估计树的继续生长对性能影响 threshold阈值 statistical test 剪枝 post pruning 决策树完全生成以后 剪原始树 将树转换为规则集 3.6 贝叶斯 贝叶斯法则 取最有个能的结果 朴素贝叶斯 BBN 梯度上升法 3.7 聚类分析 连续数据的相似性 划分聚类 层次聚类 ANNSearch and problem SolvingEvolutionary ComputatuonSwarm IntelligenceNoucelle AI","link":"/posts/62315/"},{"title":"Hexo搭建个人博客：入门","text":"使用基于Nodejs的Hexo博客框架, 结合github.io页面, 快速搭建个人博客并发布 0 先决条件 GitHub账号，相关使用见GitHub简明教程 1 工具准备1 GITHUB仓库创建​ 创建新repository，名为username.github.io(username与github用户名一致) 2 安装相关工具 安装node管理工具nvm 12345# 使用brew安装brew install nvm# 添加进终端配置文件（.zshrc或.bash_profile)export NVM_DIR=~/.nvm[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" 此处有个坑: nvm官方并不建议使用brew安装 Homebrew installation is not supported. If you have issues with homebrew-installed nvm, please brew uninstall it, and install it using the instructions below, before filing an issue. 如果使用Homebrew安装，因为安装路径等原因, 在.nvm中会缺少nvm-exec和nvm.sh两个文件。导致每次启动终端都需要输入source $(brew --prefix nvm)/nvm.sh才能使当前终端使用nvm命令 解决方法有2 简单粗暴：在.zshrc（终端配置文件）中加入source $(brew --prefix nvm)/nvm.sh 曲线救国：(注意此方法curl命令可能被墙, 具体见nvm项目github) 卸载使用brew安装的nvmbrew uninstall nvm 使用curl命令下载 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.35.2/install.sh | bash 终端配置文件加入 123export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion 安装nodejs 1nvm install stable 网上很多过期教程会建议使用 nvm install 4 , nvm install 6 , 实际安装后, node版本在7以下的都会抛出异常, 建议一步到位安装最新稳定版node nvm/npm常用命令: 1234567891011# 切换nvm版本至 &lt;number&gt;开头的默认版本nvm use &lt;number&gt; #设置默认 node 版本为 0.12.7nvm alias default 0.12.7 # 使用.nvmrc文件配置项目所使用的node版本cd &lt;项目根目录&gt; #进入项目根目录echo &lt;number&gt; &gt; .nvmrc #添加 .nvmrc 文件nvm use #无需指定版本号，会自动使用 .nvmrc 文件中配置的版本node -v #查看 node 是否切换为对应版本#安装 &lt;module-name&gt; 模块至全局目录，安装完成的路径是 /Users/&lt;username&gt;/.nvm/versions/node/&lt;nvm-version&gt;/lib/&lt;module-name&gt;npm install -g &lt;module-name&gt; nvm与n的区别 node 版本管理工具还有一个是 TJ 大神的 n 命令，n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node/npm 的外部 shell 脚本，因此 n 命令相比 nvm 更加局限。 由于 npm 安装的模块路径均为 /usr/local/lib/node_modules ，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node/npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。 安装Hexo 1sudo npm install hexo-cli -g 2 hexo的使用入门 创建博客和基础配置 12hexo init username.github.io # 博客根目录&lt;folder_name&gt;cd username.github.io 更改博客根目录下的_config.yml文件 1234567title:author:language: zh-Hans #中文theme: landscapedeploy: type: git repo: https://github.com/username/username.github.io.git 更换主题 主题测评见文章hexo的主题比较 hexo初始化中自带landscape主题 12# 此处以next主题为例git clone https://github.com/iissnan/hexo-theme-next themes/next 进入themes/next, 打开_config.yml, 按照文件中的说明即可对主题进行基础配置 同时更改博客根目录中_config.yml文件的theme: next 写文章 博客根目录username.github.io下的source文件夹保存所有博客, 默认使用md语法 hexo写作命令 1hexo new [layout] &lt;title&gt; 12345678910---title: Hexo博客搭建入门date: 2020-02-16tags: hexo jscategories: - Code - Guidekeywords: hexo js 前端 博客---Hello World! 测试hexo s 安装使用hexo-deployer-git](https://link.jianshu.com/?t=https://github.com/hexojs/hexo-deployer-git)自动部署发布工具 12npm install hexo-deployer-git --savehexo clean &amp;&amp; hexo g &amp;&amp; hexo d hexo的使用进阶基本命令 hexo init：新建一个网站 hexo new [layout] --option &lt;titile&gt; ：新建一个layout的文章，如果标题有空格，使用引号括起来 -p 自定义新文章的路径 -r 替换同名文章 -s 作为新文章的文件名和发布后的url hexo generate生成静态文件(只生成有改动的文件) -d生成后立刻部署 -w 监视文件变动 -b 抛出生成过程中的异常 -f 强制重新生成全部文件 -c 最大同时生成文件的数量 hexo publish [layout] &lt;filename&gt; 发表草稿 hexo server 打开本地服务器 hexo deploy 部署 hexo render &lt;file1&gt; [file2] 渲染文件 -o设置输出路径 写作 layout：post/page/draft 如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。 title：在_config.yaml中编辑参数改变默认名称 scaffold：根须scaffold文件夹内对应的文件来建立文件 Font-matter layout：布局 title：标题/文件名 date：建立日期 update：更新日期 comments：开启文章的评论功能 tags：标签 categories：分类 如果需要为文章添加多个分类 1234categories:- [Diary, PlayStation]- [Diary, Games]- [Life] permalink：覆盖网址 keywords：仅用于meta标签和Open Graph的关键词 标签插件 并不建议过多使用这些标签，这些标签是hexo的私有语法，迁移是会有不便，建议还是多使用md语法 hexo官网关于个别标签的演示并不完整，icarus主题的文档中有不同插件使用的Demo 引用块(quote) 等同md语法的&lt; 123{% blockquote [author[, source]] [link] [source_link_title] %}content{% endblockquote %} 代码块(code) 等同md语法的``` 123{% codeblock [title] [lang:language] [url] [link text] [additional options] %}code snippet{% endcodeblock %} line_number:flase highlight:true first_line:13 行号从第几开始 ​ 下划线特定行，即第1行和4到7行 wrap:true Pull Quote 123{% pullquote [class] %}content{% endpullquote %} jsFiddle 1{% jsfiddle shorttag [tabs] [skin] [width] [height] %} Gist(一般短代码直接插入markdown，长代码才用gist) 1{% gist gist_id [filename] %} iframe 1{% iframe url [width] [height] %} Image 1{% img [class names] /path/to/image [width] [height] '\"title text\" \"alt text\"' %} Link 1{% link text url [external] [title] %} Include 1{% include_code [title] [lang:language] [from:line] [to:line] path/to/file %} Youtube/Vimeo 12{% youtube video_id %}{% vimeo video_id %} 引用文章(我一般是当做直接引用链接fffff) 12{% post_path filename %}{% post_link filename [title] [escape] %} 引用文章的资源(关于资源文件夹的设置见本文图片部分 123{% asset_path filename %}{% asset_img filename [title] %}{% asset_link filename [title] [escape] %} Raw 插入Swig标签 123{% raw %}content{% endraw %} 文章摘要：在&lt;!--more--&gt; 之前的文字 可能会被Font Matter中的excerpt部分覆盖(需要插件支持) 图片 资源文件夹 : 最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 组织化资源管理方式 : 通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开, 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们 1![图片名称](图片名称.jpg) 需要注意, 使用md时,在首页显示会出现错误, 使用标签插件可以解决 1{% asset_img 图片名称.jpg This is an example image %} tips 在typora的设置中进行以下修改可以与hexo同步： 组织化资源管理的两种方式都会使图片失去本地编辑器上的可读性 3. 实际使用中会遇到部分主题对标签插件渲染出现莫名其妙的错误(vexo)，或者主题不支持(terminal)，所以除非需要在首页的展示缩略图，建议使用markdown语法的方式。 文件命名规范 https://adoyle.me/Today-I-Learned/others/file-naming-with-underscores-and-dashes.html","link":"/posts/2727/"},{"title":"操作系统复习","text":"北京理工大学 计算机学院 操作系统概论 复习笔记 点击下载复习大纲 点击下载习题答案 第一章 操作系统概论 早期操作系统设计的主要目标：方便性、有效性、便于设计实现维护 操作系统管理系统的什么资源：软、硬件资源 为什么要引入多道程序系统？他有什么特点：提高CPU利用率，以主存为中心 操作系统的基本功能：处理机管理、存储器管理、设备管理、文件管理 ==批处理系统、分时系统和实时系统==各有什 么特点?各适合应用于哪些方面? 批处理系统：系统吞吐量大，资源利用率高。适合计算量大、自动化程度高的成熟作业 分时系统：同时性、独立性、交互性、及时性。适合大型数据库的查询 实时系统：实时性、可靠性、确定性。适合工业生产中的自动控制、飞机导航、导弹发射 操作系统的特性：==并发行、共享性（支持并发性的物质基础）==、虚拟性、异步性（随机性） 衡量OS的性能指标： 资源利用率：在给定时间内，系统中某一资源实际使用时间所占比率 吞吐量：单位时间内系统所处理的信息量 周转时间：作业进入系统到退出系统所用的时间 什么是嵌入式系统：可裁剪的专用计算机系统 什么是对称多处理?它有什么好处? 操作系统和用户程序可安 排在任何一个处理机上运行，各处理机共享主 存和各种 I/O 设备。 为了实现系统保护，CPU通常有哪两种工作状态?各种状态下分别执行什么程序?什么时候发生状态转换?状态转换由谁实现的? 核心态、用户态 操作系统内核程序、用户程序 用户态到核心态的转换由硬件完成;核心态到用 户态的转换由内核程序执行后完成 终端和异常 什么是系统调用?什么是特权指令?特权指令执行时，CPU 处于哪种工作状态? 操作系统通常向用户提供哪几种类型的接口?其主要作用是什么? 操作接口：命令语言或窗口界面是用户使用计算机系统的主要接口。 编程接口：系统调用是用户与操作系统 之间的编程接口 第二、三章：进程管理 程序顺序执行的特点：封闭性、可再现性 进程：程序的一次执行过程 进程由哪些部分组成：进程控制块、进程描述符 进程的四大特性 动态性：临时的，有生命期的 独立性：系统进行资源分配和调度的独立单位 并发性：多个进程可在处理机上交替执行 结构性：系统为每个进程建立一个进程控制块 进程和程序的区别 进程控制块的作用是什么：进程的唯一标识 主要包括什么：一个可执行程序、一个独立的地址空间、一个执行栈区、打开的文件、申请使用的IO设备 进程的基本状态：运行态、阻塞态、就绪态、创建态、终止态 ==原语==:若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断 ==进程控制== 进程调度的功能、方式、时机、算法 功能：记录系统中各进程的执行状况、选择就绪进程占有CPU、进行进程上下文的切换 ==方式==： 非抢先方式 抢先方式 时机： 现行进程完成或错误终止 提出IO请求、等待IO完成时 在分时系统，按照时间片轮转，分给进程的时间片用完时 优先级调度 进程执行了某种原语操作 算法：先来先服务、最短作业优先、响应比高者优先、优先级调度、轮转、多级反馈队列轮转 作业调度、交换调度 作业的周转时间和作业的带权周转时间 ==线程的定义==：组成一个进程作业的许多可能的子任务 ==线程和进程的比较==：以进程为单位分配资源，以线程为单位调度执行 系统对线程的支持：用户级线程、核心级线程、两级组合 并发执行的进程在系统中的关系：顺序关系、并行关系、一般关系、互斥关系（对资源的共享）、同步关系（协作完成同一个任务）、进程之间的前序关系 临界资源：一次仅允许一个进程使用的系统中共享资源 临界区：并发进程访问临界资源的那段必须互斥执行的程序 四准则：互斥使用、让权等待、有空让进、有限等待 解决进程之间互斥的方法： 软件的实现方法 硬件的实现方法 开、关中断 加锁开锁 P、V信号量 对资源S执行P操作：申请s V：释放s ==信号量值为负时，说明有一个进程正在临界区执 行，其它的正排在信号量等待队列中等待，等待 的进程数等于信号量值的绝对值== ==在用 P/V 操作实现进程通信时，应根据 什么原则对信号量赋初值== ==IPC问题== ==进程高级通信的实现机制==：消息缓冲、信箱 、管道、共享主存区 死锁产生的必要条件及解决死锁的方法： 必要条件：互斥条件、保持和等待条件、不剥夺条件、循环等待条件 鸵鸟算法、预防、避免、检测和恢复 理解银行家算法的实质。能够利用银行家算法避免死锁。 第四章 存储器管理 存储器管理的功能：存储器分配、地址转换或重定位、存储器保护、存储器扩充、存储器共享 名字空间、==地址空间==、 存储空间、逻辑地址、物理地址。 地址重定位：把程序地址空间的逻辑地址转换为存储空间的物理地址 静态重定位：进程执行前，由装入程序把用户程序中的 指令和数据的逻辑地址全部转换成存储空间 的物理地址。 动态重定位：程序运行时，把该存储区的起始地址送入重定 位寄存器。需硬件地址转换机构。 内存划分为两大部分:用户空间和操作系统空间。存储器管理是针对用户空间进行管理的。 存储保护的目的：防止地址越界、正确进行存取 ==可变式分区管理空闲区的方法==：根据作业的大小动态地划分分区，使分区的大小正好等于作业大小 分区说明表、空闲区链表 分配算法：首次适应、最佳适应、最坏适应 设置上、下界寄存器来实现存储器保护 覆盖与交换的特点：打破了一个程序一旦进入主存， 便一直运行到结束的限制。 页表的作用：系统为每个进程建立一张页面映像表 ，记录逻辑页与主存块的映射关系 页式管理的地址变换过程 管理内存的数据结构： 什么是页式存储器的内零头（操作系统在分配内存时，有时候会产生一些空闲但是无法被正常使用的内存区域，这些就是内存碎片，或者称为内存零头）?它与页的大 小有什么关系?可变式分区管理产生什么 样的零头(碎片)? ==段式存储器管理与页式管理的主要区别是什么==： (1) 段是由用户划分的;页是为了方便管理由硬件划分 的，对用户是透明的。 (2) 页的大小固定;段的大小不固定。 (3) 段式用二维地址空间;页式用一维地址空间。 (4) 段允许动态扩充，便于存储保护和信息共享。 (5) 段可能产生主存碎片;页消除了碎片。 (6) 段式管理便于实现动态链接，页式管理只能进行静 态链接。 (7) 段与页一样，实现地址变换开销大，表格多。 虚拟存储器：是系统为了满足应用对存储器容 量的巨大需求而构造的一个非常大的地址空间 虚拟存储器的容量能大于主存容量加辅存容量之和 实现请求页式管理，需要对页表进行修改 ==状态位==：用来指示某页是否在主存 ==修改位==：指示该页调入主存后是否被修改 过。“ 1” 表示修改过，“ 0” 表示未修改过 ==访问位==：指示该页最近是否被访问 过，“ 1” 表示最近访问过，“ 0” 表示最近未访问 产生缺页中断时，系统应做哪些工作：一条指令没执行完， OS 进行缺 页中断处理后，应重新执行被中断的指令。 ==会利用 FIFO、LRU、OPT 以及时钟页面置换算法描述页面置换过程==，计算产生的缺页率。 Belady 异常：当为进程分配的主存块多时，有 时产生的缺页中断次数反而增多。 ==多级页表的概念== ==多级页表中页表建立的时机==：要访问页时，才为包含该页的页表分配空 间和建立页表页 写时复制技术的概念：若有进程要写某 页，系统就把此页复制到主存的另一个页框中 ，并更新该进程的页表，使之指向此复制的页 框，且设置该页为可读 / 写。 ==页的共享问题。需要一个专门数据结构来记录进程间共享页==：把共享页锁在内存，且在页表中增加引用计数项， 仅当其引用计数为 0 时，才允许调出或释放盘 空间。 第五章 文件系统 什么是文件和文件系统：文件系统是操作系统中最为可见的部分，由一组文件和一个目录结构组成。 文件系统的主要功能： 管理文件存储器。记录空间使用情况，分配空 间，调整或回收空间。 实现按名存取。利用目录结构快速定位文件。 应具有灵活多样的文件结构和存取方法，便于用户存储和加工处理信息。 提供一套使用方便、简单的操作命令。 保证文件信息的安全性。 便于文件的共享。 UNIX系统如何对文件进行分类：普通文件、目录文件、特别文件 它有什么好处? 文件目录的作用是什么? 文件目录项通常包含哪些内容? ==文件控制块== 文件的逻辑结构有几种形式： 无结构的字节流式文件 有结构的记录式文件 文件的存取方法 顺序存取 直接存取 ==文件的物理结构有哪几种==对于不同的结构，文件系统是如何进行管理的 连续文件： 链接文件：把文件所占 用的物理块用链接指针链接起来。 DOS系统文件 索引文件：为每个文件建立一张索引表 Unix系统文件、Ext2 索引顺序文件 NTFS DOS 文件卷的结构，DOS 系统的文件物理结构是什么：链接文件 了解记录的组块和分解：一个物理块可以存放若干个逻辑记录，一个逻 辑记录可以存放在若干个物理块中。把一个块 中存放的逻辑记录的个数叫做块因子。用户使用记录时，先将包含该记录的物理块读 入内存缓冲区，然后进行记录分解。 ==文件存储空间的管理方法有几种==?它们各是如何实现文件存储空间的分配和回收的? ==空白文件目录：系统为所有空白文件建立一张表。每个空白文件占用一个表目。适合于文件的静态分配(连续文件的分配)。 空闲块链表、空闲块成组链表（UNIX）：把所有空闲块连接成一个链表。 位映像表 (bit map) 或位示图（Ext2、NTFS）：每一个二进制位对应一 个物理盘块。为 1 时表示块已分配，为 0 时 空闲。== 建立多级目录有哪些好处?文件的重名和共享问题是如何得到解决的? 层次结构清晰，便于管理和保护; 有利于文件分类;解决重名问题;提高 文件检索速度;能够控制存取权限。 硬链接，符号链接文件 文件系统中，常用的文件操作命令有哪些?它们的具体功能是什么?打开和关闭文件命令的目的是什么? 创建：在指定设备上为指定路径名的文件建立一个目录项，并设置文件的有关属性。 删除：根据文件的路径名找到指定的目录项，回收其占用的各个物理块，再将该目录项 置为空。 打开：据文件路径名找到文件目录项，进而找到 FCB ，将 FCB 复制到内存并记录到系统打 开文件表 关闭：释放文件在主存专门区域中的目录项，切断用户与文件的联系。若该目录项被修改过，则复制到磁盘。若文件作过某些修改，应将其写回辅存。 写、追加、随机存取、得到文件属性、设置文件属性、重命名 ==存取控制表 ACL 的概念==：为存取控制矩阵中的每一列建立一张存 取控制表 (ACL) ，用一有序对 ( 域 , 权 集 ) 表示。 ==理解内存映射文件(memory mapped file)的过程== 将文件映射到进程地址空间的 一个区域，返回虚拟地址，仅当需要对文件存取 时，才传输实际的数据。 第六章 设备管理 I/O 设备通常大致可分为哪两大类?各自传输的信息单位有什么特点? 1 字符设备:人机交互设备。是以字符为单位发 送和接收数据的，通信速度比较慢。键盘和显 示器、鼠标、扫描仪、打印机、绘图仪等。 2 块设备:外部存储器。以块为单位传输数据。 常见块尺寸: 512B ~ 32KB 。如磁盘、磁带、 光盘等。 3 网络通信设备:主要用于与远程设备的通信。 传输速度比字符设备快，比块设备慢。如网卡 、调制解调器等。 4 时钟:按预先规定好的时间间隔产生中断。 常用的四种数据传输方式 程序查询方式 中断方式 DMA（直接存储器访问） 通道控制 根据设备的使用方式，设备被分为几种类型?何为虚拟设备?它是通过什么技术实现的?  独占设备:临界资源，如打印机。  共享设备:多个进程可交叉访问。如磁盘。  虚拟设备:是指设备本身是独占设备，而经过Spooling 技术虚拟技术处理，可以把它改造成共享设备。 按照设备管理的层次结构，I/O 软件划分为几层?各层主要实现哪些功能? 用户层的IO接口 中断处理程序 设备驱动程序 ==独立于设备的软件== 缓冲技术 负责设备分配和调度 出错处理 IO硬件 何为设备的独立性? (设备独立性是指用户及用户程序不受 系统配置的设备类型和具体设备的台号 的影响。用户只是使用逻辑设备，具体的 映射由操作系统完成。) ==什么是 SPOOLING 技术?以输出为例， 说明它的实现原理。(SPOOLING 技术 是以空间换时间)== 一个特定磁盘上的信息如何进行编址? 盘面号、磁道号 和扇区号(或柱面号、磁 头号和扇区号)。 要将磁盘上一个块的信息传输到主存需 要系统花费哪些时间?==(寻道时间、旋 转延迟时间和读/写传输时间）== 常用的磁盘调度算法：==先来先服务、最短寻道时间优先、扫描法== ( SCAN, C_SCAN, LOOK, C_LOOK)。 第七章 Linux进程管理 进程控制块，其中与进程管理、存储器管理和文件管理有关的一些字段，线程组标识符。 与进程创建有关的函数: fork ( )、vfork( )、clone( )。 理解进程切换的过程。涉及到页目录表、 核心栈、硬件上下文 第一步，切换页目录表以安装一个 新的地址空间 第二步，切换核心栈和硬件上 下文。由 schedule() 函数完成进程切 换 进程调度方式。进程调度时机。 可抢先式的动态优先级调 度方式 进程调度可分为:先进先出的实时进程、时 间片轮转的实时进程、普通的分时进程。 Linux 有很多内核线程，了解 0 号进程和 1 号进程的作用。 0 号进程就是一个内核线程， 0 号进程是所 有进程的祖先进程，又叫 idle 进程或叫做 swapper 进程。每个 CPU 都有一个 0 号进 程。 1 号进程是由 0 号进程创建的内核线程 init ，负责完成内核的初始化工作。在系统关闭 之前， init 进程一直存在，它负责创建和监 控在操作系统外层执行的所有用户态进程。 第八章 Linux存储器管理 进程地址空间的划分：链接虚拟内存区域的单链表 管理进程私有地址空间的数据结构：红黑树 指向映射文件对象的指针字段：struct file * vm_file; 指向进程页目录表的指针字段：pgd_t *pgd; Linux 堆的管理:malloc( )，free( )。 管理物理内存页框的数据结构： 123456789struct page {unsigned long flags; /* 页框状态标志 P172*/atomic_t _count; /*页框的引用计数*/atomic_t _mapcount; /* 对应的页表项数目 */unsigned long private; /* 由伙伴系统使用 */struct address_space *mapping; 页高速缓存pgoff_t index; 在页高速缓存中以页为单位偏移struct list_head lru; 链入活动页框链表或非活 动 ..void *virtual; /* 页框所映射的内核虚地址 */ }; 内存管理区 zone 结构： ZONE_DMA :包含低于 16MB 的常规内存 页框。用于对老式的基于 ISA 设备的 DMA 支持。  ZONE_NORMAL :包含高于 16MB 且低于 896MB 的常规内存页框。  ZONE_HIGHMEM :包含从 896MB 开始的 高端物理页框。内核不能直接访问这部分页 框。在 64 位体系结构上，该区总是空的。 123456789struct zone { unsigned long free_pages; 空闲页框数 struct per_cpu_pageset pageset[NR_CPUS]; /* 每 CPU 页高速缓存 */ struct free_area free_area[11]; /* 伙伴系统中的 11 个空闲页框链表 */ struct list_head active_list; /* 活动页框链表，存放 最近正被访问的页框 */ struct list_head inactive_list; /* 非活动页框链表， 存放最近未被访问的页框 */}; * 伙伴系统：采用伙伴系统 **(buddy system)** 管理连续的 空闲内存页框。伙伴算法把空闲页框组织成 **11** 个链表，分 别链有大小为 **1** ， **2** ， **4** ， **8** ， **16** ， **32** ， **64** ， **128** ， **256** ， **512** 和 **1024** 个连续 页框的块。 * ==分区页框分配器分配页框的过程== 理解 slab 分配器的原理：slab 分配器为不同类型的对象生成不同的高 速缓存，每个高速缓存存储相同类型的对象。 高速缓存由一连串的 slab 构成，每个 slab 包含了若干个同类型的对象。 slab 分配器的 作用：slab 分配器为只有几十或几百个字节的小内 存区分配内存。如， file 对象。 进程页表建立的时机：==页表一直推迟到 访问页时才建立，以节约内存== 了解页目录表项 或页表项所包含的字段。 逻辑地址的划分，利用两级页表实现地址转换的过程。 请求调页： 请求调页增加了系统中的空闲页框数。 所缺的页可能存放的地方。  该页从未被进程访问过，且没有相应的内存映 射。  该页已被进程访问过，但其内容被临时保存到 磁盘交换区上。  该页在非活动页框链表中。  该页正在由其它进程进行 I/O 传输过程中。 了解盘交换区空间的管理方法。  每个盘交换区都由一组 4KB 的页槽组成。  盘交换区的第一个页槽用来存放该交换区的 有关信息，有相应的描述符。  存放在磁盘分区中的交换区只有一个子区， 存放在普通文件中的交换区可能有多个子区 ，原因是磁盘上的文件不要求连续存放。  内核尽力把换出的页存放在相邻的页槽中， 减少访问交换区时磁盘的寻道时间。 第九、十章 Linux文件系统 Ext2 文件卷的布局? Ext2 把磁盘块分为组，每组包含存放在相 邻磁道的数据块和索引节点。块组的大小相 等并顺序安排。 Ext2 用“块组描述符”来描述这些块组本身的 结构信息，同时将超级块和所有块组描述符 重复存储于每个块组中。 Ext2 通过“位图”来管理每个块组中的磁盘块 和索引节点。盘块位图，索引节点位图。 各部分的作用是什 么? Linux 系统把一般的文件目录项分成哪两部分?简单目录项和索引节点两部分。 这样做的好处是什么?可以提高文件目录的检索速度。实现多条路 径共享文件，减少信息冗余。 Linux 文件系统的索引节点中，索引表 划分成几级? 文件的索引表是如何增长 的? 要求能够利用索引表实现将文件中的字节地址转换成文件的物理块的操作。 ==硬链接和符号链接的区别?==硬链接 和 源文件 是同一个文件；软链接 和 源文件 是2个不同的文件。 Linux 文件系统如何管理空闲存储空间?通过超级快和块组描述符的空闲块 VFS 通用文件模型中的四个主要对象?  超级块对象: Linux 为每个安装好的文件系统 都建立一个超级块对象。  索引节点对象:打开的文件对应的…。  目录项对象: dentry (directory entry)  文件对象:记录了进程与打开的文件之间的交互信息 Linux 系统中，进程打开一个磁盘文件 要涉及哪些数据结构?Struct tast_struct、files_struct 它们各有哪些关键字段? 1234Struct tast_struct{...... struct files_struct *files; //指向进程打 开文件信息...} 1234struct files_struct { struct file **fd; //指向文件对象指针数组 struct file *fd_array[ ]; //文件对象指针数组 ......} 他们的作用是什么 一个文件在使用与不用时各占用系统哪些资源? 安装表的作用是什么?内核将安装点与被安装的文件系统信息保存在 vfsmount 结构中，形成一个链式安装表。 第十四章 Windows模型 Windows 采用什么样的体系结构? 硬件抽象层HAL的作用是什么?直接操纵硬件。隐藏各种与硬件有关的细节。使内核 、设备驱动程序和执行体免受特殊硬件平 台差异的影响。 系统可移植性好。 Windows系统组件的基本机制包括: 陷阱调度：当检测到异常或中断发生时，将暂停正 在处理的事情，把控制转交给内核的陷 阱处理程序，陷阱处理程序再将控制转 交给相应的异常或中断处理程序。属于内核的功能。包括中断、DPC 、 APC 、异常调度、系统服务调度。 执行体对象管理器、 同步(自旋 锁、内核调度程序对象)、 本地过程调用 LPC ：服务器进程创建一个 LPC 连接端口对象，然后在该端口上监听客 户连接请求。类似 socket 编程。消息传递。 延迟过程调用 DPC：DPC 被用来执行一些相对于当前高优先级的任务来说不那么紧急的任务。 异步过程调 用 APC：为用户程序和系统代码提供了一种在特定用户线程环境中执行代码的方法。 Windows中有哪些对象，都有什么作用? ==执行体对象==：进程和线程管理器、内 存管理器、I/O 管理器、对象管理器等 ==内核对象==：内核实现的一个初级对象集， 对用户态代码不可见，仅供执行体使用。 一个执行体对象可以包含一个或多个內 核对象。) 在多处理机系统中，提供了哪些同步和 互斥机制? 内核引入自旋锁实现多处 理机互斥机制。内核以内核对象的形式给 执行体提供其他的同步机构—“调度程序 对象”，包括:进程对象、线程对象、事件 对象、信号量对象、互斥体对象、可等待 的定时器对象及文件对象等。每个同步对 象都有“有信号”或“无信号”两种状态。 ==线程如何实现等待一个同步对象的操作==：对象管理器提供WaitForSingleObject( ) ，使线程与调度 程序对象同步。 第十五章 Windows进程和线程管理 管理进程和线程的数据结构:==执行体进程块 EPROCESS、执行体线程块ETHREAD*、内核进程块 *KPROCESS、内核线程块 KTHREAD== 创建进程:CreateProcess( ); 创建线程:CreateThread( ) ==线程的 7 种状态，及其解释。== 就绪状态 (ready) 备用状态 (standby) 。已选好处理机，正等待 描述表切换，以便进入运行状态。 运行状态 (Running) 等待状态 (waiting) 传输状态 (transition) 。核心栈被调到外存的 就绪态。 终止状态 (terminated) 初始化状态 (Initialized) 。正在创建过程中。 ==线程调度:基于优先级的抢先式的多处理机调度系统。== 线程调度程序的数据结构: 32 个就绪线程队列、32 位线程就绪队列 位图、32 位处理机空闲位图。 ==线程优先级的提升时机==： I/O操作完成后的线程。 信号量或事件等待结束的线程。 前台进程中的线程完成一个等待操作。 由于窗口活动而唤醒 GUI 线程。 线程处于就绪状态超过一定时间，仍未能 进入运行状态 ( 处理器饥饿 ) 第十六章 Windows存储器管理 两种数据结构: 虚拟地址描述符 VAD：当线程要求分配一块连续虚存时，系统为它建立一个 VAD 结构。 区域对象：文件映 射对象，是一个可被多个进程共享的存储 区。 ==虚拟内存区域:空闲的、保留的、提交的== 32 位逻辑地址，二级页表。 页目录表项 和页表项具有相同的数据结构，该数据 结构包含哪些数据项? 进程页表建立的时机。进程的地址转换过程。 管理物理内存的数据结构:页框数据库。 页框的 8 种状态:活动、转换、备用、更 12改、更改不写入、空闲、零初始化、坏， 页框的状态转换图 16.9。 原型页表项，区域对象的页表。虚拟页式中，采用原型页表实现多进程共享页。 Windows 采用的页替换策略是什么?在多处理器系统中，采用了 局部先进先出置换策略。而在单处理器 系统中，更接近于最近最久未使用策略 (LRU ，也称为“时钟页面置换算法” ) 。 第十七章 Windows文件系统 Windows 所支持的文件系统类型有哪些?支持 FAT12 、 FAT16 和 FAT32 文件系统。 12 、 16 和 32 分别为描述磁盘块簇地址使 用的位数。 虚拟簇号和逻辑簇号的概念。 NTFS 卷的结构，主控文件表 MFT 的作用。 MFT 是 NTFS 卷的管理控制中心，包含了 卷上所有的文件、目录及空闲未用盘簇的 管理信息 NTFS 文件的物理结构:索引顺序结构 管理文件的目录结构采用 B-树。","link":"/posts/55434/"},{"title":"Hexo搭建个人博客：装修","text":"基于icarus主题的Hexo博客装修。本文将介绍除了icarus在_config.yml中提供的功能以外，通过修改其源代码实现的其他扩展功能，页面文件样式的进一步美化等。属于深度定制自己的主题，需要基础的CSS和HTML知识。 本文不涉及icarus主题的配置文档`_config.yml`里已经有的配置! 仅对icarus v2.6版本里未加入的功能或者个人觉得不完善的功能进行补充。由于icarus3.0中作者使用jsx取代了ejs，并且把所有能共用的js代码抽取到了inferno插件中，icarus v3请谨慎参考 参考文章 Yearito：Hexo 搭建个人博客系列 – 基于Next主题 chingow：Hexo+NexT(v7.0+) 搭建博客 – 基于Next主题，较Yearito的博客全面一些 alphalxy-Icarus 主题自定义 – 基于Icarus主题 本文所修改的主题文件已fork到GitHub仓库 先决条件 需要了解的几个文档： hexo官方文档里对于变量的说明 hexo官方文档里对于辅助函数的说明 ejs嵌入开发各个标签的含义 bulma框架中文文档 首先我们要知道icarus的文件结构。icarus采用了ejs模板语言生成页面，使用Bulma框架作为页面样式的控制框架。icatus源代码良好书写习惯的可扩展性是我们修改的基础。icarus所有的页面样式都存在themes/icarus/layout中，我们重点需要关注的文件有: 12345678910111213141516171819202122232425262728293031323334353637383940414243|-- icarus |-- _config.yml |-- includes | |-- generators | | |-- categories.js | | |-- category.js # 需要修改，换目录页为时间轴展示 | | |-- insight.js | | |-- tag.js # 后期加入，换标签页为时间轴展示 | | |-- tags.js |-- layout | |-- archive.ejs # 控制归档页页面 | |-- category.ejs # 用于控制单个目录页页面 | |-- categories.ejs # 用于控制母目录页页面 | |-- tag.ejs # 用于控制单个标签页页面 | |-- tags.ejs # 用于控制母标签页页面 | |-- custom_cat.ejs # 后期加入，模仿archive.ejs，替换category.ejs | |-- custom_tag.ejs # 后期加入，模仿archive.ejs，替换tag.ejs | |-- layout.ejs # 控制homepage的页面和比例 | |-- comment | | |-- valine.ejs # 补充源主题缺少的头像控制 | |-- common # common中存放控制各个页面共有区域 | | |-- head.ejs # 控制每个网页的&lt;head&gt;中的信息，设置seo时修改 | | |-- footer.ejs # 控制每个网页的脚注 | | |-- article.ejs # 控制博客正文页面 | | |-- navbar.ejs # 控制导航栏 | | |-- widget.ejs # 控制所有widget比例 | | |-- copyright.ejs # 后期加入，添加文末版权栏 | |-- widget # 存放各个widget界面 | |-- map.ejs # 添加访客地图widget | |-- map.locals.js # 缓存文件 | |-- music.ejs # 添加音乐widget | |-- music.locals.js # 缓存文件 |-- source |-- css | |-- back-to-top.css | |-- copyright.styl # 后期加入控制版权栏的页面样式 | |-- progressbar.css | |-- style.styl # 大部分的页面样式 |-- images | |-- thumbnail.svg | |-- Alipay.jpg | |-- wechatpay.jpg |-- js 其余我想要做改动的还有plugin文件夹，用于存放分析和计数需要的工具；search文件夹，用于存放几种搜索所需要的工具(icarus作者并没有使用hexo-generate-search的插件生成索引，而是自己写了一个insight函数生成索引列表。respect🤔。但是它的搜索展现思路变为了仅显示包含搜索条件的文章名和首行，这与我们希望显示搜索条件出现在文章的哪一处的需求不同😑) icarus v3.0中已经改变insight🔍展示文章内容 功能 插件是最简单的提升博客丰富性的方法。而多数插件只需要一行js代码就能实现 访客地球 功能：展示页面的总浏览量/页面浏览人来源的的热力图/同时在线人的地址标签 地址：RevolverMaps官网 使用方法： 在官网复制所给的js代码 在/icarus/layout/widget目录下，新建文件map.ejs和map.locals.js。把复制的js代码粘贴到map.ejs文件中，而map.locals.js中复制它隔壁的profile.locals.js中的内容即可。该文件的作用是绑定渲染该ejs文件(可以不添加) layout/widget/map.ejsmap.ejs1&lt;script type=\"text/javascript\" src=\"//rf.revolvermaps.com/0/0/6.js?i=53u8jvixw8q&amp;amp;m=7&amp;amp;c=e63100&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&amp;amp;bv=90&amp;amp;lx=-420&amp;amp;ly=420&amp;amp;hi=20&amp;amp;he=7&amp;amp;hc=a8ddff&amp;amp;rs=80\" async=\"async\"&gt;&lt;/script&gt; layout/widget/map.locals.jsmap.locals.js123module.exports = (ctx, locals) =&gt; { return locals; } 在/icarus/_config.yml配置文件中，模仿已有的widget，添加如下字段 _config.yml_config.yml123- type: map position: right 现在我们有一个访客地球的widget了! 网易云音乐 功能：网易云音乐外链播放器 地址：网易云音乐官网 使用方法： 在网易云音乐官网，登录后，选择一个歌单，点击歌单左上角的生成外链播放器，注意，歌单中不能包含VIP歌曲，否则会提示版权不允许 生成iframe插件。建议使用iframe插件，一方面是可以自己调整插件的属性，另一方面是很多浏览器现在对flash的使用有限制。复制给出的HTML代码 与添加访客地球widget的过程类似，在/icarus/layout/widget目录下，新建文件music.ejs layout/widget/music.ejsmusic.ejs1&lt;iframe class=\"card widget\" height=400 width=100% src=\"//music.163.com/outchain/player?type=0&amp;id=4878237788&amp;auto=0&amp;height=430\"&gt;&lt;/iframe&gt; 在music.locals.js填入与之前一样的绑定渲染函数 在/icarus/_config.yml配置文件中，模仿已有的widget，添加如下字段 _config.yml_config.yml123- type: netEase position: right 现在我们有一个播放器的widget了😺 人体时钟 功能：在导航栏上添加一个有交互性的小人时钟 地址：ホネホネ・クロック 時計・ブログパーツ(这个作者审美超级好🥰) 使用方法： 复制作者给的js代码： 1&lt;script charset=\"Shift_JIS\" src=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js\"&gt;&lt;/script&gt; 在/icarus/layout/common/nvabar.ejs中，在第四行，添加一个新的块。class=&quot;is-hidden-mobile&quot;是bulma框架中的一种样式，意为当屏幕宽度小于desktop时，不显示该元素。因为平板和手机的浏览器中一般没有flash插件，所以做这个处理。 /layout/coppom/nvabar.ejsnvabar.ejs1234567&lt;nav class=\"navbar navbar-main\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-brand is-flex-center\"&gt; &lt;!--以下是新插入的块 --&gt;+ &lt;div class=\"is-hidden-mobile\"&gt; + &lt;script charset=\"Shift_JIS\" src=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js\"&gt;&lt;/script&gt;+ &lt;/div&gt; 添加密码该功能由 hexo-blog-encrypt 插件提供，效果可见DUDES 使用方法参阅hexo-blog-encrypt官方文档即可 黑暗模式 imaegoo：[tutorial] support night dark mode 在命令行，进入博客的根目录 12345678910# 进入icarus目录cd themes/icarus# 添加远端仓库nightgit remote add night https://github.com/imaegoo/hexo-theme-icarus.git# 从远端仓库的night拉取night分支git pull night night# 查看并确认当前分支是mastergit status# 合并master分支和night分支，原master分支合并是不会有conflict的，如果有的话修一下git merge night 现在博客的navbar中新出现了一个小灯泡图标，点一下就能看到黑暗模式效果了 现在我们添加根据浏览器设置自动变为黑暗模式的代码，除了根据浏览器的配色模式，如果当晚/日，用户已经有与浏览器模式不同的选择，要遵循用户的选择 (即当晚浏览器是dark mode时，用户在博客内选择light mode，或相反) /source/js/night.jsnight.js12345678910+ let mode = window.matchMedia('(prefers-color-scheme: dark)').matches;+ if(mode.toString() != localStorage.getItem('current')){+ localStorage.setItem('switched', 'false');+ localStorage.setItem('current', window.matchMedia('(prefers-color-scheme: dark)').matches);+ }+ if(localStorage.getItem('switched') != 'true'){+ isNight = window.matchMedia('(prefers-color-scheme: dark)').matches;+ }findNightNav();applyNight(isNight); js获取浏览器颜色模式代码：window.matchMedia('(prefers-color-scheme: dark)').matches related post widget 在每篇博文增加一个widget，展示和这篇文章有相同tag的文章列表 添加文件layout/widget/related_posts.ejs layout/widget/related_posts.ejsrelated_posts 123456789101112131415161718192021222324252627282930313233343536373839&lt;% function build_list(tags,post) { let flag = true; return tags.map(tag =&gt; { let result =''; post.tags.map(ptag =&gt; { if( ptag.name === tag.name &amp;&amp; post.title != page.title &amp;&amp; flag === true){ if (get_config('article.thumbnail')=== true ){ result+= `&lt;article class=\"media\"&gt; &lt;a href=\"${url_for(post.link ? post.link : post.path)}\" class=\"media-left\"&gt; &lt;p class=\"image is-64x64\"&gt; &lt;img class=\"thumbnail\" src=\"${get_thumbnail(post)}\" alt=\"${post.title}\"&gt; &lt;/p&gt; &lt;/a&gt;`; } result+=`&lt;div class=\"media-content\"&gt; &lt;div class=\"content\"&gt; &lt;div&gt;&lt;time class=\"has-text-grey is-size-7 is-uppercase\" datetime=\"${date_xml(post.date)}\"&gt;${date(post.date)}&lt;/time&gt;&lt;/div&gt; &lt;a href=\"${url_for((post.link?post.link:post.path))}\" class=\"title has-link-black-ter is-size-6 has-text-weight-normal\"&gt;${post.title}&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;`; flag = false; return result; } return result; }) return result; }).join('');}%&gt;&lt;div class=\"card widget\"&gt; &lt;div class=\"card-content\"&gt; &lt;h3 class=\"menu-label\"&gt; related posts &lt;/h3&gt; &lt;% site.posts.forEach(post =&gt; { %&gt; &lt;%- build_list(page.tags , post) %&gt; &lt;% }) %&gt; &lt;/div&gt;&lt;/div&gt; 同目录下添加渲染绑定js文件related_posts.locals.js，使该widget仅对posts页面生效 related_posts.locals.js12345678module.exports = (ctx, locals) =&gt; { const { layout, content } = ctx.page; const { get_config } = ctx; if (layout !== 'page' &amp;&amp; layout !== 'post') { return null; } return Object.assign(locals, { content });} 在_config.yml中，widget下添加related_posts _config.yml1234widget:+ -+ type: recent_posts+ position: left 布局修改分栏比例 参考文章： bulma框架中文文档 Hexo&amp;icarus主题修改 我在主题修改中把比例配置抽取到_config.yml中了，可见GitHub仓库 原本icarus最大化后三栏居中，两侧会有很宽的空白，我想消灭这个空白； 我想实现的展示逻辑是，屏幕宽度足够时，首页显示三栏，博文页显示两栏；如果屏幕宽度再增加，则都显示三栏。以下把profile\\link\\recent_poat\\tag\\archive这几个widget分类为个人资料栏(统称profile栏)，top\\tagcloud\\music\\map分类为目录工具栏(统称目录栏)，中间的最大的那一栏统称博文栏。目录栏在博文页居左，个人资料栏在首页居左。 首先是icarus主题的_config.yml，加入以下配置。相关配置含义之后会做解释。我们的网页最大化后两侧宽阔的白边主要就是由于原来的配置里每一栏最后相加之和不是12(bulma的12格布局)，没有占满整个屏幕。 _config.yml_config.yml1234567proportion: homepage: # 非博文页 sidebar: 'is-one-third-tablet is-3-desktop is-3-widescreen is-one-fifth-fullhd' article: 'is-two-thirds-tablet is-6-desktop is-6-widescreen is-5-fullhd' post: #博文页面 sidebar: 'is-one-third-tablet is-3-desktop is-one-fifth-widescreen is-one-fifth-fullhd' article: 'is-two-thirds-tablet is-9-desktop is-three-fifths-widescreen is-three-fifths-fullhd' 对ejs文件的改动主要涉及三个文件layout/layout.ejs layout/common/widget.ejs以及source/css/style.styl |– icarus |-- layout | |-- [layout.ejs](https://github.com/Anne416wu/hexo-theme-icarus/blob/anne/layout/layout.ejs) | |-- common | | |-- [widget.ejs](https://github.com/Anne416wu/hexo-theme-icarus/blob/anne/layout/common/widget.ejs) |-- source |-- css | |-- [style.styl](https://github.com/Anne416wu/hexo-theme-icarus/blob/anne/source/css/style.styl) style.styl：先说css文件，因为通过这个文件我们能更好的理解bulma框架。bulma框架自动根据屏幕大小对照我们的预设适配不同比例的页面：mobile-手机/tablet-平板/desktop-pc/widescreen-全屏/fullhd-全屏。至于不同屏幕对应哪个大小，我们可以采用icarus原有的方案，也可以用更为严格的方案： 12345gap = 64pxscreen-tablet = 769pxscreen-desktop = 1088pxsscreen-widescreen = 1280pxscreen-fullhd = 1472px 根据我的经验，使用13inch的mbp，按照icarus原有的方案，屏幕的1/3是手机模式，屏幕的2/3是平板(tablet)模式，大于屏幕的2/3是pc(desktop)模式，大于屏幕的8/9是全屏(widescreen)模式 layout.ejs：更改控制博文栏占页面比例的函数main_column_class()： layout/layout.ejslayout.ejs12345678910111213141516&lt;% function main_column_class() { switch (column_count()) { case 1: return 'is-12'; case 2: return 'is-8-tablet is-8-desktop is-8-widescreen'; case 3: if(is_post() === false){ return get_config('proportion.homepage.article'); } else{ return get_config('proportion.post.article'); } } return '';} %&gt; _config.yml中对应设置含义：当存在三栏的配置时，如果屏幕大于平板小于pc，博文栏占2/3；如果屏幕大于pc小于全屏，对于博文页，博文栏占9/12(即3/4)，对于非博文页，博文栏占6/12(即1/2)；如果屏幕大于全屏，博文栏占3/5；fullhd以此类推 12345proportion: homepage: article: 'is-two-thirds-tablet is-6-desktop is-6-widescreen is-5-fullhd' post: article: 'is-two-thirds-tablet is-9-desktop is-three-fifths-widescreen is-three-fifths-fullhd' layout/common/widget.ejs 更改控制边栏占页面比例的函数side_column_class()： layout/common/widget.ejslink1234567891011121314_&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: if(is_post() === false){ return get_config('proportion.homepage.sidebar'); } else{ return get_config('proportion.post.sidebar'); } } return '';} %&gt; _config.yml中对应设置含义：当存在三栏的配置时，当屏幕大于平板小于pc，仅显示左侧栏，占1/3，当屏幕大于pc小于全屏，博文页仅显示左侧栏，占3/12，非博文页显示左右两栏，各占3/12；以此类推 12345proportion: homepage: sidebar: 'is-one-third-tablet is-3-desktop is-3-widescreen is-one-fifth-fullhd' post: sidebar: 'is-one-third-tablet is-3-desktop is-one-fifth-widescreen is-one-fifth-fullhd' 更改控制模块可见性的函数visibility_class()：如果页面不是博文页，当屏幕小于或等于平板时，仅显示左侧栏，当屏幕大于平板时，左右侧栏都显示；如果页面是博文页，当屏幕小于或等于PC大小时，仅显示左侧栏，当屏幕大于pc时，左右侧栏都显示 layout/common/widget.ejslink123456789&lt;% function visibility_class() { if(is_post()===false &amp;&amp; column_count() === 3 &amp;&amp; position === 'right'){ return 'is-hidden-touch'; } if(is_post()===true &amp;&amp; column_count() === 3 &amp;&amp; position === 'left'){ return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt; 更改控制侧栏输出顺序的函数order_class()：当页面是博文页，目录栏在左侧，profile栏在右侧；当页面不是博文页，profile栏在左侧，目录栏在右侧 layout/common/widget.ejslink12345678&lt;% function order_class() { if(is_post() === true){ return position === 'left' ? 'has-order-3' : 'has-order-1'; } else{ return position === 'right' ? 'has-order-3' : 'has-order-1'; }} %&gt; 更改主函数，大概从第27行开始，做下述更改。这里函数原本的意思是，在屏幕小于全屏时，将右侧栏合并到左侧栏显示。我们更改为，当页面不是博文页且屏幕大小小于pc时，将右侧栏合并到左侧栏 layout/common/widget.ejslink1234- &lt;% if (position === 'left') { %&gt;+ &lt;% if (position === 'left' &amp;&amp; is_post() === false ) { %&gt;- &lt;div class=\"column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;\"&gt;+ &lt;div class=\"column-right-shadow is-hidden-desktop\"&gt; 至于说手机端的情况，反正只有一栏，保持原来的设置不变就好了，但是原来的设置中手机端首页是先显示博文再显示profile等widget，而我希望手机端的首页先展示profile的widget，这个非常容易，在layout/layout.ejs中 layout/layout.ejslayout.ejs123&lt;%- _partial('common/widget', { position: 'left' }) %&gt;&lt;div class=\"column &lt;%= main_column_class() %&gt; has-order-2 column-main\"&gt;&lt;%- body %&gt;&lt;/div&gt;&lt;%- _partial('common/widget', { position: 'right' }) %&gt; 这三行，如果第二行放在最前，手机端首页就先显示博文索引再显示所有widget，如果第一行放在前，手机端首页就先显示属性为left的widget，再显示属性为right的widget，最后显示博文索引。以此类推。 同时，如果手机端进入除了首页之外的其他主页(目录页归档页等)，profile widget也会被放在最前，我们并不需要在这些页面展示profile wideget，因此，在layout/common/widget.ejs中，在visibility()函数中添加以下选择语句： layout/common/widget.ejslink123if(is_home()===false &amp;&amp; is_post()===false){ return 'is-hidden-mobile';} 时间轴展示目录页 原生的icarus这两页的展示方式与homepage一致，依次展示按块展示每篇博客的标题和简介。这样的展示效率并不高。我希望把这两页的展示方式替换为和存档archive页相同的时间轴显示 我们要用到的文件有：|– includes| |– generators| | |– category.js| | |– tag.js|– layout| |– archive.ejs| |– custom_cat.ejs| |– custom_tag.ejs 修改目录页生成器/includes/generators/category.js：在第23行，把默认输出页面样式的archive排到最前即可 includes/generators/category.jscategory.js 12- layout: ['category', 'archive', 'index'],+ layout: ['archive', 'category', 'index'], 这样修改后，进入目录页，比如Code/Guide后，页面就会按照时间轴显示该分类下所有文章，但是时间轴的标签依旧是2020\\2019，而且文章的信息只有日期似乎有些寡淡了，如果我们想展示文章字数/展示文章阅读人数/让标签显示分类的名称呢？ 其实非常简单。我们在layout文件夹下，新建一个文件custom_cat.ejs 复制archive.ejs中的代码到custom_cat.ejs 修改时间轴标签为分类名称：第六行，进行替换 layout/custom_cat.ejscustom_cat.ejs1234&lt;h3 class=\"tag is-link\"&gt;- &lt;%= month === null ? year : time.locale(get_config('language', 'en')).format('MMMM YYYY') %&gt;+ &lt;%= page.category %&gt;&lt;/h3&gt; 显示文章的字数和估计阅读时间：在第十九行的class=content块的&lt;time&gt;标签中，添加&lt;span&gt;块 layout/custom_cat.ejscustom_cat.ejs123456789&lt;div class=\"content\"&gt; &lt;time class=\"has-text-grey is-size-7 is-block is-uppercase\" datetime=\"&lt;%= date_xml(post.date) %&gt;\"&gt;&lt;%= date(post.date) %&gt;+ &lt;span&gt;+ &amp;nbsp;&amp;nbsp;&amp;nbsp;+ &lt;% const words = word_count(post._content); %&gt;+ &lt;% const time = duration((words / 150.0) * 60, 'seconds') %&gt;+ &lt;%= `${ time.locale(get_config('language', 'en')).humanize() } ${ __('article.read')} (${ __('article.about') } ${ words } ${ __('article.words') })` %&gt;+ &lt;/span&gt; &lt;/time&gt; 添加阅读次数。 尽管busuanzi十分方便，但是它不支持在目录页显示每篇文章的阅读量(=_=就是一个API)，所以我们要换用一个新的页面统计工具，为防止此部分篇章过长，相关配置将放到本文的阅读量统计替换部分。 以下代码未通过测试，请勿使用 在custom_cat.ejs的第四十行左右，进行以下内容的添加 layout/custom_cat.ejscustom_cat.ejs12345678910111213141516&lt;% if (post.categories &amp;&amp; post.categories.length) { %&gt; &lt;div class=\"level-item is-size-7 is-uppercase\"&gt; &lt;%- list_categories(post.categories, { class: 'has-link-grey ', show_count: false, style: 'none', separator: ' / ' }) %&gt; &lt;/div&gt;&lt;% } %&gt; &lt;% if (has_config('comment.appID') &amp;&amp; get_config('comment.type') === 'valine') { %&gt; &lt;span class=\"level-item has-text-grey is-size-7 is-uppercase\"&gt; &lt;i class=\"far fa-eye\"&gt;&lt;/i&gt; &lt;%- _p('plugin.visit', '&lt;span data-hk-page=\"post.url\"&gt;&lt;i class=\"fa fa-spinner fa-spin\"&gt;&lt;/i&gt;&lt;/span&gt;') %&gt; &lt;/span&gt;&lt;% } %&gt; 再次修改目录页生成器category.js includes/generators/category.jscategory.js 1layout: ['custom_cat', 'category', 'index'], 完成!🤩 ​ 用相似的方法，我们修改tag页 添加生成器/includes/generators/tag.js。具体内容可参考tag.js 添加layout/custom_tag。内容可参考 custom_tag.ejs 这里说明一下，这里标签的修改只做了最简单的替换，我并没有去动archive里原本的生成函数，所以时间轴的逻辑依然是按照时间顺序排列，按照年份分区。如果希望能修改为按照分类的子目录分区–我尝试了hexo提供的category.parent category.children等重构函数，但遇到了几个异常抛出。这个bug先留一下吧。 categories页合并tags页layout/layout.ejslayout.ejs12345678910111213141516171819 &lt;section class=\"section\"&gt; &lt;div&gt; &lt;div class=\"columns is-centered\"&gt; &lt;div class=\"column &lt;%= main_column_class() %&gt; has-order-2 column-main\"&gt; &lt;%- body %&gt;+ &lt;% if (is_categories() === true) { %&gt;+ &lt;%- _partial('tags') %&gt;+ &lt;%- _partial('archive') %&gt;+ &lt;% } %&gt;+ &lt;% if (is_tags() === true) { %&gt;+ &lt;%- _partial('categories') %&gt;+ &lt;%- _partial('archive') %&gt;+ &lt;% } %&gt; &lt;/div&gt; &lt;%- _partial('common/widget', { position: 'left' }) %&gt; &lt;%- _partial('common/widget', { position: 'right' }) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 警告块在source/css/style.styl中添加如下样式： 1234567891011121314151617181920212223242526272829/* --------------------------------- * Add tip block * --------------------------------- */.content .tip { position: relative; margin: 2em 0; padding: 12px 24px 12px 30px; border-left: 4px solid #f66; border-top-right-radius: 2px; border-bottom-right-radius: 2px; background-color: #f6f8fa;}.content .tip:before { content: \"!\"; position: absolute; top: 14px; left: -12px; width: 20px; height: 20px; border-radius: 100%; font-family: Dosis, \"Source Sans Pro\", \"Helvetica Neue\", Arial, sans-serif; font-size: 14px; line-height: 20px; font-weight: bold; text-align: center; background-color: #f66; color: #fff;}.content .tip br { display: none; } 在写作时，使用以下代码即可 123&lt;div class=\"tip\"&gt; 这里是警告块内容&lt;/div&gt; 效果： 这里是警告块内容 ### 页末版权 在layout/common下添加文件copyright.ejs。内容可参考copyright.ejs 在source/css下添加文件copyright.styl。内容可参考copyright.styl。其中提供两种样式：my-post-copyright和post-copyright 在source/css/style.styl中导入copyright.stylsource/css/style.styl1234/* --------------------------------- * Add Copyright CSS * --------------------------------- */@import copyright 在layout/common/article.ejs中插入copyright.ejs1234567&lt;div class=\"content\"&gt; &lt;%- index &amp;&amp; post.excerpt ? post.excerpt : post.content %&gt;&lt;/div&gt;+ &lt;% if (is_post()===true) { %&gt;+ &lt;%- _partial('common/copyright') %&gt;+ &lt;% } %&gt;&lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt; Valine 头像 icarus3已修复此bug icarus原生配置中没有默认的Valine头像值 打开icarus/layout/comment/valine.ejs，插入avatar的配置信息 layout/comment/valine ejsvaline1234567891011 &lt;script&gt; new Valine({ el: '#valine-thread' ,+ avatar: 'retro', notify: &lt;%= get_config('comment.notify') %&gt; , verify: &lt;%= get_config('comment.verify') %&gt; , app_id: '&lt;%= get_config('comment.app_id') %&gt;', app_key: '&lt;%= get_config('comment.app_key') %&gt;', placeholder: '&lt;%= get_config('comment.placeholder') %&gt;', });&lt;/script&gt; 评论默认头像将会变为八位像素复古头像，如果用户在gravatar注册过，则会显示注册的绑定头像 Valine更多默认头像设置参考Valine头像配置 数据统计和优化SEO优化 知乎专栏：hexo博客搭建（五）SEO优化 评论邮件回执 Valine Admin 配置手册 修改阅读量统计服务为leancloud 参考文章 https://www.githang.com/2019/05/30/hexo-article-reading-statistics-based-on-leancloud/ https://jerryzou.com/posts/introduction-to-hit-kounter-lc/ https://github.com/bulandent/hexo-theme-bubuzou/blob/master/doc/doc-zh.md 因为我们在配置Valine时已经注册了leancloud，所以这里就以leancloud为例。 ------ to be continued ------ ### 添加ads Hexo接入Google AdSense广告 Gulp压缩123456npm install gulp --savenpm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save gulp-imagemin 模块有问题 添加Gulpfile 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');var babel = require('gulp-babel');// gulp-babel 取消严格模式方法(\"use strict\")var removeUseStrict = require(\"gulp-remove-use-strict\");// 压缩css文件gulp.task('minify-css', function (done) { return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public')); done();});// 压缩html文件gulp.task('minify-html', function (done) { return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, })) .pipe(gulp.dest('./public')); done();});// 压缩js文件gulp.task('minify-js', function (done) { return gulp.src(['./public/**/*.js', '!./public/**/*.min.js']) .pipe(babel({ //将ES6代码转译为可执行的JS代码 presets: ['es2015'] // es5检查机制 })) .pipe(uglify()) .pipe(removeUseStrict()) //取消严格模式方法(\"use strict\") .pipe(gulp.dest('./public')); done();});// 压缩 public/images 目录内图片(Version&lt;3)// gulp.task('minify-images', function () {// gulp.src('./public/images/**/*.*')// .pipe(imagemin({// optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级）// progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片// interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染// multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化// }))// .pipe(gulp.dest('./public/images'));// });// 压缩 public/images 目录内图片(Version&gt;3)gulp.task('minify-images', function (done) { gulp.src('./public/images/**/*.*') .pipe(imagemin([ imagemin.gifsicle({interlaced: true}), imagemin.jpegtran({progressive: true}), imagemin.optipng({optimizationLevel: 5}), imagemin.svgo({ plugins: [ {removeViewBox: true}, {cleanupIDs: false} ] }) ])) .pipe(gulp.dest('./public/images')); done();});//4.0以前的写法 //gulp.task('default', [// 'minify-html', 'minify-css', 'minify-js', 'minify-images'//]);//4.0以后的写法// 执行 gulp 命令时执行的任务gulp.task('default', gulp.series(gulp.parallel('minify-html', 'minify-css', 'minify-js')), function () { console.log(\"----------gulp Finished----------\"); // Do something after a, b, and c are finished.});","link":"/posts/65512/"},{"title":"Hexo搭建个人博客：部署","text":"通过创建远端git仓库，将本地的hexo博客部署到远端服务器并通过Nginx服务运行 参考文章：芒果浩明 已将nginx替换为Caddy，相关文章见使用Caddy替换Nginx运行网站 操作环境及先决条件 本地macOS Catalina centOS 7的VPS 本地需要的相关环境：git、nodejs、hexo、ssh-key，相关文章见hexo博客搭建入门 服务器配置使用root身份登录服务器ssh root@IP 创建网站目录 12# 创建网站文件夹sudo mkdir /var/www/blog 安装配置git 安装gitsudo yum install git 创建git用户 adduser git 假如没有提示输入密码，则passwd git 设置密码 初始化git仓库 1234# 设置文件可写chmod 740 /etc/sudoers# 编辑用户配置文件vim /etc/sudoers 找到root ALL=(ALL) ALL，换行添加git ALL=(ALL) ALL 1234567# 修改回文件权限chmod 440 /etc/sudoerssu git # 切换到git用户cd /home/git # 切换到git用户目录mkdir blog.git # 创建git仓库文件夹，以blog.git为例cd blog.git # 进入仓库目录git init --bare # 使用--bare参数初始化为裸仓库 确认文件夹权限 123456# 确认文件夹权限sudo chown git:git -R /var/www/blogsudo chown git:git -R /home/git/blog.git# 查看这两个文件夹是不是都属于git:gitll /home/git/ll /var/www/ 配置Git hooks 12cd /home/git/blog.git/hooks # 切换到hooks目录下vim post-receive # 创建文件 复制下面的内容到post-receive中： 12345678#!/bin/bashGIT_REPO=/home/git/blog.gitTMP_GIT_CLONE=/tmp/blogPUBLIC_WWW=/var/www/blogrm -rf ${TMP_GIT_CLONE}git clone $GIT_REPO $TMP_GIT_CLONErm -rf ${PUBLIC_WWW}/*cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW} 保存退出，执行chmod +x post-receive赋予可执行权限 配置ssh免密登录这一步可以省略，如果省略之后git部署的时候输入git的用户密码即可 本地电脑创建SSH key（已有则跳过此步骤） ssh key是让我们每次登陆的时候无需输入密码，通过本机机器码验证的方式 1234567 # 查看本地的SSH key cd ~/.sshls *.pub # 创建新的SSH keyssh-keygen -t rsa -C \"email@example.com\" # 将key加入用户列表，否则每次都会需要验证电脑登录密码ssh-add -k /Users/apple(Username)/.ssh/id_rsa 复制cat ~/.ssh/id_rsa.pub的内容 ssh连接到服务器，配置ssh秘钥登录 123cd /home/git # 切换到git用户目录mkdir .ssh # 创建.ssh目录sudo vim .ssh/authorized_keys 将复制的本地公钥粘贴到到authorized_keys文件中， 编辑登录配置sudo vim /etc/ssh/sshd_config 12345#禁用密码验证PasswordAuthentication no#启用密钥验证RSAAuthentication yesPubkeyAuthentication yes 重启ssh服务 12su root # 或者exit也可以退出到root用户service sshd restart 验证git用户能否使用ssh免密登录服务器：在本地终端，输入ssh git@IP 如果出现permission denied的的话，可能是权限问题 12chmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys 注意 .ssh 目录与 authorized_keys 的拥有者都必须是你创建的那个用户。比如我创建了一个叫 wanghao 的用户，寻它应该是 .ssh 与 authorized_keys 的拥有者，并且必须要设置合适的权限： 安装和配置nginx nginx是比较主流的网页服务器，大部分的文章都会建议使用。但是nginx的https连接配置较为复杂，如果没有特别的学习需求可以换用更为简单的Caddy。相关文章见Caddy官方文档 root用户身份登录到服务器 12345678# 添加nginx到yum源sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm# 安装nginxsudo yum install -y nginx# 启动nginxsudo systemctl start nginx.service# 设置开机启动sudo systemctl enable -n nginx.service 在浏览器输入服务器IP地址，如果出现403 FORBIDDEN页面则说明nginx启动成功； 如果浏览器提示无法链接，请检查防火墙是否开启，如果开启 使用systemctl stop firewalld暂时关闭防火墙； 或者使用firewall-cmd --add-port=80/tcp --permanent开启防火墙的80端口，再使用systemctl restart firewalld.service重启防火墙。 关于防火墙的详细配置，可见本博客文章VPS和Shadowsocks配置最后一部分 nginx常用命令 1234567891011121314151617#启动service nginx start#停止nginx -s stop#查看nginx进程ps -ef | grep nginx#平滑启动nginxnginx -s reload #强制停止nginxpkill -9 nginx#检查对nginx.conf文件的修改是否正确nginx -t -c /etc/nginx/nginx.confnginx -t#查看版本nginx -v# 关闭开机启动sudo systemctl disable -n nginx.service 配置nginx 123cd /etc/nginx/conf.dsudo cp default.conf default.bak#备份sudo vim default.conf 配置文件参考 123456789101112131415161718192021222324server { listen 80; server_name localhost; root /var/www/blog; // 网站根目录 server_name annewqx.top www.annewqx.top; // 域名，没有可跳过 access_log /var/log/nginx/blog_access.log; error_log /var/log/nginx/blog_error.log; error_page 404 = /404.html; location / { root /var/www/blog; index index.html index.htm; } location / { root /var/www/blog; if (-f $request_filename) { rewrite ^/(.*)$ /$1 break; } } location /nginx_status { stub_status on; access_log off; }} nginx -s reload 重启nginx 本地操作 打开本地博客根目录下的_config.yml文件，找到最后的deploy配置，添加： 123456789# Deploymentdeploy:# github.io- type: 'git' repo: https://github.com/anne416wu/anne416wu.github.io.git # VPS- type: git repo: git@VPS的IP:blog.git branch: master 至此,hexo三联就可以把博客部署到vps了。可以在浏览器输入服务器的IP地址查看。 如果想要通过域名访问,则需要自己在域名管理那里修改解析的线路使得域名解析指向vps服务器的ip git 配置完SSH 以后，push 或者pull 的时候每次都提示Enter passphrase for key ‘/Users/Username/.ssh/id_rsa’可以这样解决 一次性：终端输入eval ssh-agent，ssh-add 本次开机内永久生效：终端输入ssh-add -k /Users/m/.ssh/id_rsa 域名配置(非必须) 参考文章： Namesilo 域名购买及使用教程 Namesilo DNS 域名解析教程和常见问题解决方法汇总 博客已经搭好了，但是叫朋友看 购买域名 注册并激活NameSilo账号 搜索并购买想要注册的域名，使用优惠码go2think或okoff可减$1 付款，如果使用支付宝，则支付宝需要是绑定了邮箱的账号。我购买的时候支付宝扣了钱后半分钟又退回了，返回了失败，最后还是用的PayPal。 这里说一下题外话，最便宜的一般是.xyz域名，不到1刀，但是如果订单不满1刀的话是无法使用优惠券的。.top的域名原价$1.49/year，优惠后约等于不要钱啊。 另外长远考虑，不建议购买.me等国内无法备案的域名。 域名解析 打开域名管理页面，选择option栏下的蓝地球(DNS管理)按钮 删除原本的四个park解析记录 添加A记录，一条为example.com，一条为www.example.com DNS解析完成后生效大改需要十五分钟 可以使用域名连接你的博客了，在浏览器输入域名查看结果","link":"/posts/65182/"},{"title":"Hexo搭建个人博客：主题比较","text":"hexo各个主题的比较 我的需求 目的：记录开发中遇到的坑，形成自己的handbook 功能： 🔍站内搜索LeanCloud统计 🤥 Valine的评论服务 较为友好的代码高亮 有展示GitHub project（接入GitHub的API）的project页面 seo支持 界面： 首页tagCloud和categories的Widget 首页的index展示文章的tag和category标签 单篇博文内有随页面变化的目录widget archive展示时间轴 各个theme评价基于jade ( pug )开发的主题 Jade 是一个高性能的模板引擎，它深受 Haml 影响，它是用 JavaScript 实现的，并且可以供 Node 使用，后来由于商标的原因，改为Pug 以下列举的主题都仍然使用hexo-renderer-jade插件，npm会提示插件已被废弃，运行时会显示错误提示。首先要替换hexo-renderer-jade插件为hexo-renderer-pug，下载命令为npm install hexo-renderer-pug --save；然后将主题layout文件夹中的所有.jade文件替换为.pug文件 入门指南：[pug中文文档](https://pugjs.org/zh-cn/api/getting-started.html) Apollo 博客首页博客归档页 界面干净，多个theme都基于apollo开发，如Gandalfr Hermes artemis bubuzou pandollo 缺点: 功能缺乏，需要自己接入评论、目录、搜索、Widget等功能； bubuzou 博客首页博文底部 基于apollo开发, 补充大量apollo缺乏的功能，如评论、目录、搜索、Widget；评论支持Valine评论； 首页 css页面适配存在缺陷（缩放时borden过小），代码高亮有缺陷，个别博文底部不会出现评论窗口(奇奇怪怪的bug) 实际使用的时候发现leancloud的访问量统计功能有缺点，留个坑； 1234567p.visit i(class=&quot;article-timer&quot;, data-identity=item.path) span 次访问 if (is_home()) i(data-hk-page='http://anne416wu.github.io'+url_for(item.path)) - else i(data-hk-page=&quot;current&quot;) Gandalfr 不放图了，这玩意儿bug挺多。有意思的是作者写了个tagCloud的辅助插件，给TagCloud加上了动画效果。界面上较bubuzou更贴近apollo。 有时间的可以把Gandalfr的界面和bubuzou的功能结合一下。 基于ejs开发的主题 ejs是一套简单的模板语言，利用普通的 JavaScript 代码生成 HTML 页面，相比上面使用jade，修改更为方便。个人体验感觉ejs性能的确不如jade。 Vexo博客首页博文开头归档页项目页 满足对界面的一切幻想(对界面的幻想都是这个主题惯出来的)，支持多种代码高亮 缺点：未接入搜索功能，仅支持gitment评论，无首页CLoudTag的Widget等 本地运行存在bug。使用hexo s预览时，如果文章资源读取出现错误，整个博客页面会显示空白 Cactus 博客首页博文开头归档页 界面干净，支持多种代码高亮 因为是国外开发的，对本地化的支持较少； &lt;–未完待续–&gt; 基于Swig开发的主题","link":"/posts/27751/"},{"title":"VPS和Shadowsocks配置","text":"VPS服务器的创建、Shadowsocks的配置 最新文章ss to v2ray中，建议更换ss为v2ray 参考网址 Jerryzhou-shadowsocks的基本安装配置 itrhs-进阶使用 1 注册和创建Droplets 在此跳过VPS的注册和购买过程，目前可以使用的VPS服务商中比较有名的，国外有Vurtlr、Linode、DigitalOcean，国内有阿里云、腾讯云，具体对比见 可以免费换的VPS商家盘点 笔者使用的是Digital Ocean，附上优惠码：https://m.do.co/c/438f7c8cc2dd，当时注册的时候据说送50刀，但当时耽搁了开始使用的时间，隔了一个月没用就过期了 系统是 CentOS 7 x64 - Enable IPV6 非CentOS7可能导致后续出现python等缺失 本地创建SSH key（已有则跳过此步骤） ssh key是让我们每次登陆的时候无需输入密码，通过本机机器码验证的方式 123456789# 查看本地的SSH keycd ~/.sshls *.pub# 创建新的SSH keyssh-keygen -t rsa -C \"email@example.com\"# 将key加入用户列表，否则每次都会需要验证电脑登录密码ssh-add -k /Users/apple/.ssh/id_rsa# 复制本地公钥cat ~/.ssh/id_rsa.pub 将公钥添加到DO账号Security中 这个时候使用本机公钥即可远程登录服务器，当然不配置也可以使用密码登录的方式 1ssh root@IP地址 修改密钥登陆为密码登陆的方法： 12# 编辑ssh配置文件 vi /etc/ssh/sshd_config 找到以下字段，并修改为： 12PermitRootLogin yes # 允许根用户登录PasswordAuthentication no # 打开密码登录 重启ssh服务service sshd restart 2 Shadowsocks CentOS7自带python2.7，所以直接安装pip 12yum -y install pippip install shadowsocks 创建配置文件 1vim /etc/shadowsocks.json 配置文件内容： 123456789101112131415161718192021222324252627282930313233343536373839//普通配置{ \"server\":\"服务器ip地址\", \"server_port\":8388, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"你设置的密码\", \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false}// 多端口配置// 即把server_port和password两项替换为port_password{ \"server\": \"服务器ip地址\", \"server_ipv6\": \"::\", \"local_address\": \"127.0.0.1\", \"local_port\": 1081, \"port_password\": { \"8686\":\"你设置的密码\", \"8687\":\"你设置的密码\", \"8688\":\"你设置的密码\", \"8689\":\"你设置的密码\", \"8690\":\"你设置的密码\" }, \"timeout\": 120, \"udp_timeout\": 60, \"method\": \"aes-256-cfb\", \"protocol\": \"auth_sha1_v4_compatible\", \"protocol_param\": \"\", \"obfs\": \"http_simple_compatible\", \"obfs_param\": \"\", \"dns_ipv6\": false, \"connect_verbose_info\": 1, \"redirect\": \"\", \"fast_open\": false, \"workers\": 1} ssh服务器启动 1234567ssserver -c /etc/shadowsocks.json# 或者在后台运行ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop# 日志ssserver -c /etc/shadowsocks.json --log-file /tmp/ss.log -d starttail -f /tmp/ss.log 附加：vim的安装和配置 安装vim 1yum install vim 配置vim 1vi ~/.vimrc vim配置文件参考 123456789101112131415161718192021222324252627282930313233\" Configuration file for vimset modelines=0 \" CVE-2007-2438\" Normally we use vim-extensions. If you want true vi-compatibility\" remove change the following statementsset nocompatible \" Use Vim defaults instead of 100% vi compatibilityset backspace=2 \" more powerful backspacing\" Don't write backup file if vim is being called by \"crontab -e\"au BufWrite /private/tmp/crontab.* set nowritebackup nobackup\" Don't write backup file if vim is being called by \"chpass\"au BufWrite /private/etc/pw.* set nowritebackup nobackuplet skip_defaults_vim=0syntax onautocmd InsertLeave * se noculautocmd InsertEnter * se culset tabstop=4set softtabstop=4set shiftwidth=4set numbercolorscheme pabloset rulerset scrolloff=3set rtp+=/usr/local/opt/fzf 3 速度升级和安全性 配置防火墙（可能导致后续安装锐速服务后出现模块冲突，建议最后再打开防火墙） yum install firewalld 123452. 配置防火墙文件： ```bash vi /etc/firewalld/zones/public.xml 一个端口对应两个 123456789101112131415161718 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;zone&gt;&lt;short&gt;Public&lt;/short&gt;&lt;service name=\"dhcpv6-client\"/&gt;&lt;service name=\"ssh\"/&gt;&lt;port protocol=\"tcp\" port=\"8686\"/&gt;&lt;port protocol=\"udp\" port=\"8686\"/&gt;&lt;port protocol=\"tcp\" port=\"8687\"/&gt;&lt;port protocol=\"udp\" port=\"8687\"/&gt;&lt;port protocol=\"tcp\" port=\"8688\"/&gt;&lt;port protocol=\"udp\" port=\"8688\"/&gt;&lt;port protocol=\"tcp\" port=\"8689\"/&gt;&lt;port protocol=\"udp\" port=\"8689\"/&gt;&lt;port protocol=\"tcp\" port=\"8690\"/&gt;&lt;port protocol=\"udp\" port=\"8690\"/&gt;&lt;port protocol=\"tcp\" port=\"8691\"/&gt;&lt;port protocol=\"udp\" port=\"8691\"/&gt;&lt;/zone&gt; 重启shadowsocks，重启防火墙 12# 重启防火墙systemctl restart firewalld.service firewalld的基本使用 启动： systemctl start firewalld 关闭： systemctl stop firewalld 查看状态： systemctl status firewalld 开机禁用 ：systemctl disable firewalld 开机启用 ：systemctl enable firewalld 查看开放的端口：firewall-cmd --list-ports 添加端口：firewall-cmd --zone=public --add-port=59008/tcp --permanent（–permanent永久生效，没有此参数重启后失效) 查看所有被占用的端口 netstat -tunlp 下载锐速服务（建议直接使用下一条四合一脚本） 12345678910# 对于centOS7 需要先下载需要的固件20140911 rpm -ivh ftp://ftp.pbone.net/mirror/ftp.scientificlinux.org/linux/scientific/7.0/x86_64/updates/security/linux-firmware-20140911-0.1.git365e80c.el7.noarch.rpm# 更换内核wget --no-check-certificate -O rskernel.sh https://raw.githubusercontent.com/hombo125/doubi/master/rskernel.sh &amp;&amp; bash rskernel.sh# 内核更换完后显示Success后需要重新连接到服务器ssh root@IP地址# 查看当前内核版本uname -r# 下载锐速，一路回车安装yum install net-tools -y &amp;&amp; wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh &amp;&amp; bash appex.sh install bbr 原版/魔改/plus+锐速 四合一脚本 123456789101112# 下载脚本wget \"https://github.com/cx9208/Linux-NetSpeed/raw/master/tcp.sh\" &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh# 如果证书错误的话apt-get -y install ca-certificatesyum -y install ca-certificates# 1-3中选择切换内核，自动重启，如果出现是否删除Configuring image,选择no# 调用脚本./tcp.sh# 在4-8中选择要开的加速 \"1. 安装 BBR/BBR魔改版内核\" 对应4,5,6（原版，魔改，暴力魔改） \"2. 安装 BBRplus版内核 \" 对应7（plus） \"3. 安装 Lotserver(锐速)内核\" 对应8（锐速） 服务器测速 speedtest 12345678# 断链接wget -qO- git.io/superbench.sh | bash# 使用参数wget -qO- git.io/superbench.sh | bash -s infowget -qO- git.io/superbench.sh | bash -s iowget -qO- git.io/superbench.sh | bash -s speedwget -qO- git.io/superbench.sh | bash -s fastwget -qO- git.io/superbench.sh | bash -s share","link":"/posts/9931/"},{"title":"使用Caddy替换Nginx运行网站","text":"Caddy的使用真的太傻瓜了! 参考文章： 入门： Caddy中文文档 中阶： 3mile：如何在CentOS 7上安装和配置Caddy Caddyfile的配置：liuzhichao：替换 Nginx 使用 Caddy 作为博客静态服务器 脚本介绍： Caddy-最容易上手的Web Server 本博客基于Caddy中文文档，结合其他文章进行介绍，上接本博客博文把hexo博客部署到VPS服务器，请注意，这次我们需要一个域名。 介绍为什么要用 Caddy 替换掉 Nginx ？最主要的原因是 Caddy 能让网站自动支持 HTTPS。同样是使用 Let’s Encrypt，换成 Nginx 我们就必须手工操作，并且还需要设置三个月更新证书的计划任务。Caddy默认支持 http/2，很多东西都不需要我们配置了。另外它的配置文件也比 Nginx 的要简单很多，几十行的 Nginx 配置文件 Caddy 仅需要几行就可以搞定了。关于能否将Caddy用作正式的生产环境，目前来看还是有待商榷的，但是Caddy用为简单的Http服务器是没有问题的。 先决条件 一个搭载CentOS 7 x64的VPS服务器 一个域名example.com已被配置为指向VPS IP，具体方法参见把hexo博客部署到VPS服务器 域名部分 已经利用git把hexo博客部署到VPS的/var/www/blog文件夹 如果已经运行nginx的，需要nging -s stop关闭 安装 我们使用Caddy官方的一键安装脚本 大部分caddy的第三方一键脚本对于centOS都仅支持6.8或7.2版本(查看Linux版本方法cat /etc/centos-release) sayem314 在Linux，Mac或BSD操作系统上，使用以下命令安装Caddy最新稳定的系统特定版本： 1curl https://getcaddy.com | bash -s personal Caddy二进制文件将被安装到该/usr/local/bin目录。使用以下命令确认： 1which caddy 为了安全起见，切勿以root身份运行Caddy二进制文件。为了让Caddy能够以非root用户的身份绑定到特权端口（例如80,443），需要setcap。按如下所示运行该命令： 1sudo setcap 'cap_net_bind_service=+ep' /usr/local/bin/caddy 测试默认情况下，Caddy使用当前目录（执行命令的目录，而不是caddy二进制文件所在目录）作为网站根目录，因此运行本地站点非常方便。 使用终端或者命令行，切换到站点目录所在： 12cd path/to/my/site # 在我们的服务器上是/var/www/blogcaddy 浏览器打开http://localhost:2015/，如果出现404页面，说明caddy运行正常。使用`Ctrl+C`退出，caddy将尽可能优雅中断。 配置方案1：来自Caddy官方文档的快速开始 如果服务器设置了防火墙，则打开80和443端口 123sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload 请确保你的域名能解析到你的服务器，具体方法参见把hexo博客部署到VPS服务器 最后一部分 1sudo caddy -host example.com 当第一次使用一个真正的域名（不是localhost）运行Caddy时，会出现提示要求输入你的email地址。这是因为Caddy需要验证你的域名，并将验证信息安全地存储在硬盘上。 Caddy必须将40和443端口绑定到一个真正的站点，这需要root或者Administrator的权限 现在我们的网站已经按照在运行了! &lt;全文完&gt; &lt;其实并不，Caddy可以很简单的开始，但总有高阶玩家可以把简单的事情变得更复杂，当然，也更安全&gt; 方案2：从Caddyfile开始创建一个专门的系统用户：caddy 和一组同名的Caddy： 1sudo useradd -r -d /var/www -M -s /sbin/nologin caddy 注意：此处创建**的用户caddy只能用于管理Caddy服务，不能用于登录。 /var/www为Caddy Web服务器创建主目录，并/var/www/blog为您的站点创建主目录： 12sudo mkdir -p /var/www/blogsudo chown -R caddy:caddy /var/www 创建一个目录来存储SSL证书： 123sudo mkdir /etc/ssl/caddysudo chown -R caddy:root /etc/ssl/caddysudo chmod 0770 /etc/ssl/caddy 创建专用目录来存储Caddy配置文件Caddyfile： 12sudo mkdir /etc/caddysudo chown -R root:caddy /etc/caddy 创建名为的Caddy配置文件Caddyfile 以下仅是一个普通配置，详细的配置参见本文Caddyfile部分 12345678910111213141516171819sudo touch /etc/caddy/Caddyfilesudo chown caddy:caddy /etc/caddy/Caddyfilesudo chmod 444 /etc/caddy/Caddyfilecat &lt;&lt;EOF | sudo tee -a /etc/caddy/Caddyfilewww.example.com { redir https://example.com{uri}}example.com { root /var/www/blog gzip tls example@outlook.com header / Strict-Transport-Security \"max-age=31536000\" gzip errors { 404 404.html 403 403.html } }EOF 使用caddy -conf /etc/caddy/Caddyfile 按照配置文件运行caddy。第一次运行会验证邮箱，并进行ssh申请等，等待后将网页浏览器指向http://example.com或https://example.com。可看到网站运行的样子 关于Caddyfile的书写解释，可见本文Caddyfile部分 方案3：使用caddy.service(此部分有缺陷，未解决) github: systemd Service Unit for Caddy 这部分目前我遇到的问题 使用systemctl status caddy.service提示用户错误。错误的原因一个是systemd version太低，虽然caddy.service要求是219即可，实际上大概是需要229以上才行； 文件夹权限的问题，涉及到用户和用户组，不太熟，如果把自己搞得ssh拒绝登录就傻了； 等有时间的时候再回头修这个吧😑 为了方便Caddy的操作，我们可以使用systemd为Caddy 设置一个单元文件，然后用它systemd`来管理Caddy。 123curl -s https://raw.githubusercontent.com/mholt/caddy/master/dist/init/linux-systemd/caddy.service -o /etc/systemd/system/caddy.service # 从 github 下载 systemd 配置文件chown root:root /etc/systemd/system/caddy.service # 配置权限chmod 744 /etc/systemd/system/caddy.service 启动Caddy服务并使其在系统引导时自动启动： 12345678# 重启systemd使服务生效sudo systemctl daemon-reload# 开始运行caddy服务sudo systemctl start caddy.service# 设置开机自启动sudo systemctl enable caddy.service# 查看caddy服务运行状态sudo systemctl status caddy.service 最后，将网页浏览器指向http://example.com或https://example.com。可看到网站运行的样子。 Caddyfile **Caddyfile**用来告诉Caddy如何提供服务的文本文件。他通常和网站放在一起。 12cd path/to/sitevim Caddyfile Caddy的一般结构如下： 12345678910111213141516171819202122232425262728293031www.mysite.com { redir https://mysite.com{uri}}mysite.com { root /var/www/blog log / /var/log/caddy/mysite.log \"{remote} {when} {method} {uri} {proto} {status} {size} {&gt;User-Agent} {latency}\" tls 邮箱账号 header / Strict-Transport-Security \"max-age=31536000\" gzip errors { 404 404.html 403 403.html } expires { match .css$ 1m match .js$ 1m match .png$ 1m match .jpg$ 1m } ipfilter / { rule block blockpage /var/www/liuzhichao.com/403.html ip 148.251.8.250 136.243.37.219 144.76.38.40 69.197.177.50 199.58.86.211 5.9.97.200 144.76.91.79 } rewrite { if {&gt;User-agent} has \"MJ12bot\" to /forbidden } status 403 /forbidden} 说明： 123www.mysite.com { redir https://mysite.com{uri}} 是将 www 跳转到非 www 的域名。 1tls mail@mysite.com tls后面改为你的邮箱地址，会自动配置 https。 1header / Strict-Transport-Security \"max-age=31536000\" 是一条 https 的优化配置，加上之后，在SSLLabs上测试评分可以拿到A+,想想之前使用 Nginx 的时候，网络上找了各种配置参考都只优化到了 A，所以 Caddy 的自动 Https 功能确实还是很方便的。 1234errors { 404 404.html 403 403.html } 是自定义错误页面配置。确保你网站的根目录有相应的文件，不然启动服务会报错。 123456expires { match .css$ 1m match .js$ 1m match .png$ 1m match .jpg$ 1m } expires 是控制页面的缓存，上面的配置是将 css,js,png,jpg 这样的静态资源缓存1个月。此配置依赖http.expires这个插件，如果你没有安装，配置后启动 caddy 会出错。 12345ipfilter / { rule block blockpage /var/www/liuzhichao.com/403.html ip 148.251.8.250 136.243.37.219 144.76.38.40 69.197.177.50 199.58.86.211 5.9.97.200 144.76.91.79 } ipfilter是根据配置过滤到一些非正常的 IP，可以查看访问log，经常会有一些爬虫频繁的访问网站，没有任何用处反而加大服务器的负载，对于这样的 IP 可以直接过滤掉。blockpage是配置这些 IP 访问网址时显示的页面，依赖http.ipfilter插件。 12345rewrite { if {&gt;User-agent} has \"MJ12bot\" to /forbidden } status 403 /forbidden 与上面的ipfilter功能类似，都是过滤掉一些非正常的访问用户，不同的是ipfilter是屏蔽 IP，这段配置则是根据User-agent block掉一些爬虫。","link":"/posts/2210/"},{"title":"Anaconda的环境管理","text":"常用的Conda命令 Conda的环境管理Conda的环境管理功能允许我们同时安装若干不同版本的Python，并能自由切换。对于上述安装过程，假设我们采用的是Python 2.7对应的安装包，那么Python 2.7就是默认的环境（默认名字是root注意这个root不是超级管理员的意思）。假设我们需要安装Python 3.4，此时，我们需要做的操作如下： 12345678910111213141516171819# 创建一个名为python34的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本）conda create —name python34 python=3.4# 安装好后，使用activate激活某个环境activate python34 # for Windowssource activate python34 # for Linux &amp; Mac# 激活后，会发现terminal输入的地方多了python34的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH# 此时，再次输入python —version# 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境# 如果想返回默认的python 2.7环境，运行deactivate python34 # for Windowssource deactivate python34 # for Linux conda deactivate python34 # for mac# 删除一个已有的环境conda remove —name python34 —all 用户安装的不同python环境都会被放在目录~/anaconda/envs下，可以在命令中运行conda info -e查看已安装的环境，当前被激活的环境会显示有一个星号或者括号。说明：有些用户可能经常使用python 3.4环境，因此直接把~/anaconda/envs/python34下面的bin或者Scripts加入PATH，去除anaconda对应的那个bin目录。这个办法，怎么说呢，也是可以的，但总觉得不是那么elegant……如果直接按上面说的这么改PATH，你会发现conda命令又找不到了（当然找不到啦，因为conda在~/anaconda/bin里呢），这时候怎么办呢？方法有二：1. 显式地给出conda的绝对地址 2. 在python34环境中也安装conda工具（推荐）。 Conda的包管理 Conda的包管理就比较好理解了，这部分功能与pip类似。例如，如果需要安装scipy： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 安装scipyconda install scipy# conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）# 查看已经安装的packagesconda list# 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包# 安装scipyconda install scipy# conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）# 查看已经安装的packagesconda list# 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包### conda的一些常用操作如下：# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n python34# 查找package信息conda search numpy# 安装packageconda install -n python34 numpy# 如果不用-n指定环境名称，则被安装在当前活跃环境# 也可以通过-c指定通过某个channel安装# 更新packageconda update -n python34 numpy# 删除packageconda remove -n python34 numpy# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n python34# 查找package信息conda search numpy# 安装packageconda install -n python34 numpy# 如果不用-n指定环境名称，则被安装在当前活跃环境# 也可以通过-c指定通过某个channel安装# 更新packageconda update -n python34 numpy# 删除packageconda remove -n python34 numpy### 前面已经提到，conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本，例如# 更新conda，保持conda最新conda update conda# 更新anacondaconda update anaconda# 更新pythonconda update python# 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本### 补充：如果创建新的python环境，比如3.4，运行### conda create -n python34 python=3.4### 之后，conda仅安装python 3.4相关的必须项，如python, pip等，如果希望该环境像默认环境那样，安装anaconda集合包，只需要：# 在当前环境下安装anaconda包集合conda install anaconda# 结合创建环境的命令，以上操作可以合并为conda create -n python34 python=3.4 anaconda# 也可以不用全部安装，根据需求安装自己需要的package即可# 在当前环境下安装anaconda包集合conda install anaconda# 结合创建环境的命令，以上操作可以合并为conda create -n python34 python=3.4 anaconda# 也可以不用全部安装，根据需求安装自己需要的package即可# 设置国内镜像### 如果需要安装很多packages，你会发现conda下载的速度经常很慢，因为Anaconda.org的服务器在国外。所幸的是，清华TUNA镜像源有Anaconda仓库的镜像，我们将其加入conda的配置即可：# 添加Anaconda的TUNA镜像conda config —add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/# TUNA的help中镜像地址加有引号，需要去掉# 设置搜索时显示通道地址conda config —set show_channel_urls yes# 添加Anaconda的TUNA镜像conda config —add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/# TUNA的help中镜像地址加有引号，需要去掉# 设置搜索时显示通道地址conda config —set show_channel_urls yes 执行完上述命令后，会生成~/.condarc(Linux/Mac)或C:UsersUSER_NAME.condarc文件，记录着我们对conda的配置，直接手动创建、编辑该文件是相同的效果。","link":"/posts/52525/"},{"title":"ssr to v2ray","text":"三月一日到了，成熟的小孩要学会自己换梯子的协议了 引用连接： 官方GitHub：v2ray/v2ray-core 官方网站：Project V Mac/Windows/Android客户端： 图形客户端 一键式脚本 233boy/v2ray（Github内容已经不展示） 指导手册 （需要翻墙） 指导手册备用地址 V2Ray 是一个于 Shadowsocks 之后非常好用的代理软件，但是由于 V2Ray 的配置略复杂，GUI 客户端不完善，所以 V2Ray 并没有像 Shadowsocks 在科学上网人群之中那么流行。 但目前来看ssr的服务越发不稳定，所以我们需要换用v2ray 0 先决条件 本文前导文章为 VPS和Shadowsocks配置 开了firewalld防火墙的话请自行添加对应端口 1 服务端配置 如果已经使用其他方式安装v2ray，想要换为脚本，删除方法如下： 卸载：其中 systemd 和 sysv 二选一，取决于你的系统 1234567#停用并卸载服务（systemd）：systemctl stop v2raysystemctl disable v2ray#停用并卸载服务（sysv）：service v2ray stopupdate-rc.d -f v2ray remove 删除残留文件： 12345rm -rf /etc/v2ray/* #(配置文件)rm -rf /usr/bin/v2ray/* #(程序)rm -rf /var/log/v2ray/* #(日志)rm -rf /lib/systemd/system/v2ray.service #(systemd 启动项)rm -rf /etc/init.d/v2ray #(sysv 启动项) 参考：v2ray-core/issues/187 可选用的脚本(来源：V2Ray中文网 » 好用的 V2Ray 一键脚本整理与分享 V2Ray 官方一键脚本V2Ray 官方提供 V2Ray 一键脚本，新手可以非常方便的在自己的 VPS 上一键搭建 V2Ray，详细介绍参考：V2Ray 官方教程：V2Ray 官方一键脚本搭建与配置文件生成。 233 V2Ray 一键脚本233 V2Ray 一键脚本是由 233boy 开发并维护的一个 V2Ray 脚本，是目前用的比较广泛的 V2Ray 一键脚本，自带管理面板与加速功能，详细介绍参考：233 V2Ray 一键脚本，自带管理与加速功能，v2ray.sh。 V2ray.Fun 一键脚本V2ray.Fun 是一个比较常用的 V2Ray 一键脚本，由 FunctionClub 开发并维护，这个脚本自带 Web 可视化控制面板，详细介绍参考：V2Ray 一键脚本，自带 Web 可视化控制板面板，V2ray.Fun 我选用的是233boy的脚本 ssh登陆到服务器root用户，使用一键式脚本安装 bash &lt;(curl -s -L https://git.io/v2ray.sh) 选择[1]安装； 选择默认传输协议TCP； 没有特别需要的话，回车确认默认端口； 广告拦截默认关闭(专业的人做专业的事)； 是否配置Shadowsocks看自己的需要(不过既然我们都从ss过来了，就不用了吧) 安装完成后，输入v2ray url 得到vmess URL；或者v2ray qr 得到二维码链接 备份脚本 将脚本Fork一份：备份地址 Fork后，安装在服务器上 1234git clone https://github.com/你的GitHub用户名/v2ray -b mastercd v2raychmod +x install.sh./install.sh local # 此即为运行脚本 常用命令： v2ray info 查看 V2Ray 配置信息v2ray config 修改 V2Ray 配置v2ray link 生成 V2Ray 配置文件链接v2ray infolink 生成 V2Ray 配置信息链接v2ray qr 生成 V2Ray 配置二维码链接v2ray ss 修改 Shadowsocks 配置v2ray ssinfo 查看 Shadowsocks 配置信息v2ray ssqr 生成 Shadowsocks 配置二维码链接v2ray status 查看 V2Ray 运行状态v2ray start 启动 V2Rayv2ray stop 停止 V2Rayv2ray restart 重启 V2Rayv2ray log 查看 V2Ray 运行日志v2ray update 更新 V2Rayv2ray update.sh 更新 V2Ray 管理脚本v2ray uninstall 卸载 V2Ray 2 客户端配置 打开客户端-服务器设置-左上服务器列表中‘+’-右侧url后复制粘贴刚刚得到的vmess URL即可 或者打开刚刚得到的二维码链接，直接在菜单中选择扫描屏幕上的二维码 因为v2ray的多入口多出口特性， 一个 V2Ray 进程可并发支持多个入站和出站协议，每个协议可独立工作，因此如果没有统计流量的需要，几人共用的话，不用做分割，如果有需要，请看下一部分 锐速或者加速服务我们依然可以用VPS和Shadowsocks配置 中的四合一脚本wget &quot;https://github.com/cx9208/Linux-NetSpeed/raw/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh 重启服务即可 多用户配置 233boy的v2ray脚本中似乎没有关于这方面的快速命令，因此需要我们自己动手 使用cat /proc/sys/kernel/random/uuid新建一个用户id，记下这个ID号 打开v2ray配置文件vi /etc/v2ray/config.json 12345678910111213141516171819202122232425262728293031{ \"inbounds\": [ { //这是第一个用户的配置 \"port\": 12345, //端口号 \"protocol\": \"vmess\", \"settings\": { \"clients\": [ { \"id\": \"f8123442-a199-4ba3-b66c-3751234fbb47\", //USER ID \"level\": 1, \"alterId\": 64 } ] } }, //注意这个逗号 // 这是第二个用户的配置 { \"port\": 12346, //新的端口号 \"protocol\": \"vmess\", \"settings\": { \"clients\": [ { \"id\": \"0ff12347-7664-65d9-b10a-5b1234050c07\", //刚刚记下的USER ID \"level\": 1, \"alterId\": 64 } ] } }//注意这里没有逗号], 即完成多用户配置 使用 v2ray restart 命令重启服务 打开自动生成inbound的json文件和客户端配置链接的网站，把刚刚的新用户配置输入,点击生成链接，然后输入服务器IP，得到二维码和链接，添加到服务端即可 PAC设置从GFW LIST地址更新PAC文件 黑名单：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 白名单：https://raw.githubusercontent.com/R0uter/gfw_domain_whitelist/master/data/whitelist.pac 手动编写PAC文件以ipip.net为例 需要走代理，全匹配 1||ipip.net^ 需要直连，不走代理 1@@||example.com 详细语法规则 123456789101112131415161718192021222324=== 通配符支持 =&gt; **.example.com/ 代表 http://example.com http://233.example.com https://233.example.com https://666.example.com/233.mp4 全部走代理。同时\"*\"可省略，.example.com/ 与 *.example.com/ 效果是一样的 === 正则表达式支持以 \\ 开始和结束，\\[\\w]+:\\/\\/example.com\\ === 例外规则 =&gt; @@@@*.example.com/ 表示\"@@\"后面的网址规则(*.example.com)不走代理如：@@www.baidu.com 表示 www.baidu.com 不走代理 === 匹配地址开始和结尾规则 =&gt; ||http://example.com、example.com| 分别表示 以http://example.com开始 和 以example.com结束 的地址如：|http://233.com ，代表 http://233.com 开头的网址才会走代理，即 https://233.com http://1.233.com 都不会走代理如：233.com|，代表 233.com 结尾的网站才会走代理，即 http://233.com https://233.com http://1.233.com 都会走带了，而 http://233.com/index.html 不会走代理。 === 全匹配规则 =&gt; ||||example.com 则代表 http://example.com、https://example.com、ftp://example.com 等协议的地址全部走代理如：||233.com ，即 http://233.com、https://233.com、ftp://233.com 等地址全都走代理 === 注释规则 =&gt; !!我是注释233!我也是注释666","link":"/posts/30155/"},{"title":"GitHub简明教程","text":"正是Github，让社会化编程成为现实。 什么是 Github?github是一个基于git的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。Github 由Chris Wanstrath, PJ Hyett 与Tom Preston-Werner三位开发者在2008年4月创办。迄今拥有59名全职员工，主要提供基于git的版本托管服务。目前看来，GitHub这场冒险已经胜出。根据来自维基百科关于GitHub的描述，我们可以形象地看出GitHub的增长速度：今天，GitHub已是： 一个拥有143万开发者的社区。其中不乏Linux发明者 Torvalds 这样的顶级黑客，以及Rails创始人 DHH 这样的年轻极客。 这个星球上最流行的开源托管服务。目前已托管431万git项目，不仅越来越多知名开源项目迁入GitHub，比如Ruby on Rails、jQuery、Ruby、Erlang/OTP；近三年流行的开源库往往在GitHub首发，例如： BootStrap 、 Node.js 、 CoffeScript 等。 alexa全球排名414的网站。 注册账户以及创建仓库要想使用github第一步当然是注册github账号了， github官网地址： https://github.com/ 。 之后就可以创建仓库了（免费用户只能建公共仓库），Create a New Repository，填好名称后Create，之后会出现一些仓库的配置信息，这也是一个git的简单教程。 Github 安装 下载 git OSX 版 下载 git Windows 版 下载 git Linux 版 配置Git首先在本地创建ssh key；$ ssh-keygen -t rsa -C “your_email@youremail.com”后面的your_email@youremail.com改为你在github上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在~/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key。回到github上，进入 Account Settings（账户配置），左边选择SSH Keys，Add SSH Key,title随便填，粘贴在你电脑上生成的key。为了验证是否成功，在git bash下输入：$ ssh -T git@github.com 如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。 接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。 12$ git config —global user.name “your name”$ git config —global user.email “your_email@youremail.com” 进入要上传的仓库，右键git bash，添加远程地址：$ git remote add origin git@github.com:yourName/yourRepo.git后面的yourName和yourRepo表示你再github的用户名和刚才新建的仓库，加完之后进入.git，打开config，这里会多出一个remote “origin”内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。创建新文件夹，打开，然后执行 git init 以创建新的 git 仓库。 检出仓库执行如下命令以创建一个本地仓库的克隆版本：git clone /path/to/repository如果是远端服务器上的仓库，你的命令会是这个样子：git clone username@host:/path/to/repository 工作流你的本地仓库由 git 维护的三棵”树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。你可以提出更改（把它们添加到暂存区），使用如下命令： 12git add &lt;filename&gt;git add * 这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：git commit -m “代码提交信息”现在，你的改动已经提交到了 HEAD*，但是还没到你的远端仓库。推送改动你的改动现在已经在本地仓库的 *HEAD 中了。执行如下命令以将这些改动提交到远端仓库：git push origin master可以把 /master/ 换成你想要推送的任何分支。 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：git remote add origin &lt;server&gt;如此你就能够将你的改动推送到所添加的服务器上去了。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，/master/ 是”默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。创建一个叫做”feature_x”的分支，并切换过去：git checkout -b feature_x切换回主分支：git checkout master再把新建的分支删掉：git branch -d feature_x除非你将分支推送到远端仓库，不然该分支就是 /不为他人所见的/：git push origin &lt;branch&gt; 更新与合并要更新你的本地仓库至最新改动，执行：git pull以在你的工作目录中 /获取（fetch）/ 并 /合并（merge）/ 远端的改动。要合并其他分支到你的当前分支（例如 master），执行：git merge &lt;branch&gt;在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现/冲突（conflicts）/。 这时候就需要你修改这些文件来手动合并这些/冲突（conflicts）/。改完之后，你需要执行如下命令以将它们标记为合并成功：git add &lt;filename&gt;在合并改动之前，你可以使用如下命令预览差异：git diff &lt;source_branch&gt; &lt;target_branch&gt; 标签为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 /1.0.0/ 的标签：git tag 1.0.0 1b2e1d63ff/1b2e1d63ff/ 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：git log你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。 替换本地改动假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：git checkout — &lt;filename&gt;此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：git fetch origingit reset —hard origin/master 实用小贴士内建的图形化 git：gitk彩色的 git 输出：git config color.ui true显示历史记录时，每个提交的信息只显示一行：git config format.pretty oneline交互式添加文件到暂存区：git add -i 链接与资源图形化客户端 GitX (L) (OSX, 开源软件) Tower (OSX) Source Tree (OSX, 免费) GitHub for Mac (OSX, 免费) GitBox (OSX, App Store) 指南和手册 Git 社区参考书 专业 Git 像 git 那样思考 GitHub 帮助 图解 Git","link":"/posts/48683/"},{"title":"Dudes","text":"陪你自己 31c8c841cc4f8fabb2f96e9146d5230cb19ae73b4cf4c21171e887d6abe6d76f602dfede4bd1e801825ff56f06fbae10eee6c2872efe25890faf5c3a06945609e05cc22d641494d2020bded2c66c529c4184ab63b1cb47141cdfc49b31fd062cbc055da70641450dc08abb9de89cf0f8ea1568d636102f89a57bc75f3260a2f61e0c4b2532c3376892f1e8cceb16d9567ab562e53a85b0db667b01486652b9d96f1288a9cb366a53b4af8b7a6fe5e3c9ed32b02f87aa90049c3c0916f7797e887e7ca1c6173134590a3388ecf878c3e2c907db3014c225b7c13f710a90522e8bbd59f2f22f31edca2c2615194f27bf8c85e3e936ae2a66568262285e037a683f9e96940038f2428080c42ce262f53313fe22ecfd66034014194e7fb7234485ef903c421f11bcbd2fc92c4e1303748e57bf16728f7f0de18e2ea3bfcb7af7423b360d145ac876f08550033d92c4e874a1cadbc828b7d6ecfa2c74208b5a35aed91bcad2cd336860ef9b1f08843843503f949b4ceba24c3d1e0d90412a972f17fd93885092800b37cc3e62f6590b8743428944450ca0e61d883ec7b3e2101129dd40f7b4ca4321ea2069d71544581155f664628e815230ee16f73648d6dc94741b6baf484112e854f41b0f49ac37f7af005bf2242d3374401fe512708e84e6900df3cf18e39271d58e10c303b0bb5e1843ac6a9932e44f9f16745f53183a7ccb058647e032d4aaea85d33abded2818bf835ad5375ef5d791786b663dde6796478335afbe01670dd6d5822df342dbc121be15def95b820d0f9aa194f2bc488115965259431cc0ad0a6025196cfc508fe972eb1bf29c675a742439639da41a6b4dd5f4d96439ba069a667a1044d7dd8f28c72f2c4eead931979e9033c089eecbf67d7ff66ece68d35f44614cbac50fed9fa176f668ca20571428cfbdd1c88e093c9fcca485797213d37a0bccfe2178f08ab8770879835ab1d12e13faef6672d0350162b5c19672a53318191979c331c0d45fc066461f10f8e91d586b83e2cf0ca26c57d26968f3766904e4285ac377e15d8a5ffacf1fae09e4c89efaad4f0629e8f446892e40952401c129af7c36347449ea5075f87b4522dba35ae136d1e5edbf514263915744b0831afa5578f1bdc49562d4c190bbacbfecf6eabe567de572a0b595665c5685384e4369d8733ce33f6f30b791a3b4939a1aa5948be66a93f580bf7cebe822a2fd18ab1cf299e21b033df297add416ec9038033962ae865b1d1aea1eb1ec4d7be9582899b947450dfef9b192095f1d0e9842a52afa5918d475332cdff27b4989d3b2fb3e2443cfe15772c1581e6bcb83d514da37183bf4a2e54f2291d1567d7c925439fb23bfba916a247b69231b9a2456e03e4273946f41e0eeb45789ec43304d34a08d9016fe86307bcba80d49c4be3f53a92998aff984e4ae447aae0a1a640f8a7d8e141f03ce761135186ae2875f65123df491fe9918fe6275e37111164cb620a7f00ffaadaf2988d1c4099b841ca62c8654a720f1197cdc792900196bc53cde326dcd79be7985c437027492df10901537d5d6fde5485af25c16ce1adcf6085638fa3b7fdee3f998e644542ddd9db6c3eea1ef2f2c7614d22d3ebb980d65d0a9662daff5a4854ff8cec094b272986e90dd1e1a9ad5b70ffd4d23ee645aac45d0de8010199e233b26dc0f337ce75c3a5d83afa422f3fe7e25f3ad7078600946746907b12f9426fb6c2340537b221e285d9631bce2262297b1f918dc85e6de75451b34ef27d4886d316533a13508ff9352da9a5a3523247a5df17347a6aeae706f40c1f75a1a808b653e190a10adab35bb6b0ea18e09ee63c894fb29b3b0f14ed191c21761e041d93c3a6aa9845500ed434f9fd0c096758ffa8060c938c91c57eb366cc19a5d7f2937ec8895bde3b01dadb8e99b2d7734bbf98cf3a91c1a33ba547edf4194b28cea622492fefab3ad36ed86b2405cd6075766a71ac33a680f9805fd89bca629e51aa999f97453710a6562117d95349d0f5853f6691e5a1fea90bbb93cdd0b7c6e1ebb5d294660c36685c7d47c05d31cca6bdcca65915d872f157beeec48bfc2d59b99d3560328fa3edcea0d9543f069478d6231eb1a3e2fcfaa1e952837fb773f44869a3dea5a6d819e28bd1015ab329ff6755c47d7164601793ea9ba78d315bceb5b9749b12756d295ba78c48f8adc2b494172804f6b666232ee461ecac7a4fe36a986ec1f23f71db20f77eb2c4a273ff74e6e13381a476e9db68fc78c240f89df74b03499332a83b181fdd08c2818408987b17fcdb63e98c2d6151acd3314d0a86846fdbf497a46cacb36628cb5a798ae6aebccca2b4d71cd17571b55871f4712dcb8033a52fa56ca3bc85ceecfd87c64de5b6e2c5af83393517bc928dcaf46e6ba5d604294defa185e1c1b70406afe2861d94af9cae61aa163931e3ecb69a1f360b0317a0c39b675d2f1628d9f3d23aa958dc267c8c7a9364b15b9fbff6eb2fd42d42ce8f100942ead98c631c24a05730a1e3519b103721942b5a1b84c87ec0d0ca03bafc6f740c2881b8111a37c05655394b3257cab1065f1cf68b9de5c4d6d159bb12951fd9a113a4f84e51d19ab8f7fd26c5a6e1a95fdf05a446b9e1d7f50c323665c2d1aa38da3196ba888e12cff7d67cbf767affb1ffdc638c65631fa97191c4fc7f5328fbb4d829c8c76b97c8d8f3215d8550fc2d3d73fc204545f247368319c50702eaca1b8a7af60d7e1d19f168dea925e971318d0b643984ee8e80c37557543f511af45d7a6322b67b1165f78654213bd5ea8093b4c651e2e8557a96b516714a6476515ad5f33f771e198e059155e040cc69bfd91b18aeafdafbc845e78e616741b7248a0bdd22851bb72a469bf6dfe49cf071d17a7af2e2908e6e579e90bca9d7c1bddd6bfd940d261a519c2d9aa9b58e8a83e4a8ff787c7e04035bbb28c7a75bd93e5ec8b803b8f7c14aea71f3c90ed2f7e6a1f1c8988400a17eacd4d7ea3deefb88c5dfc0b9daf041d7b28d4fb1acf9a49f9825641ec5c9f5a737b7dd2cf441455d0897cb0365110225e014ad59b0646369b83b7d826f9bddc98b6ed2193939e3f74f422b44edc970477ee38ef569096f211a1b7f6de974d6fa1c556f723b6d492c51cba262a93e5aabe2b391316364a39907b6cad8aa984e489b3cde5fd4ded5dde70b6fc95222dcdc07a3cce92222ff0b4262ef73b92248328697d73b092f21ff5d493953c30967dac5cae39f161a62e289eb6756b550f3a58fe414d3eef7c3e8f88d2137fdc5d1ded0d458387321a349a61e7c4a7a1e0920ed266d3d155433740fe4368f711c5a5c37078234e8a2ba061099944270913af75f04703927793fafe30999e7e8de3ee4a650164a911cbb3517e53307e396dd9648a9fdddf10c024008558afac45ec977cadf4e3d5ca1324aaccd479e1ee50f116e7a69fc0857bd4e012ce91b791f7dd667b35aa7e2c269273b03e88a9db3fc079a44168b5b8c6307343302c4e9e265135da4cb23edaf3a4ead79034e8adb84c71006eefd8472134b2e68c6191718ea13af30ba08176544ab7123e897d7e6c57c3c7aa14a22e8a362a3d64e88133757234dee9117bc0de632c0a72bb92fa77cfb1adc84bdf0832fc104b6f1ebbdd38b679f4c2da81629665b5e3d79017b7c846c38c522fe332838507dbc212666ed3a6fe5e72ec1b41ab61843115f74e6d8e069d527d73988e9c8d6aaf49c6a0131d4b568ad79a6eca01afe92375463e0e3a36c7e86eb79720a694c4858159dc9d95ccb549fa515a59fd900e2e45696624c5721b030442af51dd991fe2e9a8161758ec992672b47ca7e9b5f18dac325b742de29f6da61fe8b44607605bdc8cc407333ed229fddd69745c0b1d62d24d64ad811f40b9568c7702a9508ebe025e1f9fe0811d55c6f7ff637e0c89ef671abedc9eb6db3c4dcec0ec456c695896d4fb9012782e70488af5a793b20bcdfcf52923fe1613142792ef6e24c33c7b58e40533738f265ae66bb9344466c46dfbde172c9f33eb63ba64d5e4c09f85927eabaa1f5e1de514d8dead2e679373e1af78b4d8eb22ec5bade49b858da3eb1097ea1891621b888b553ca1faeee0b6aa4d706d44cc32363c6e60bdbffdefd51561e7c88b2b1b420842e161da8cdc48e42b08fbb011dccd2b45aa4e0b7c18f6a8c1e92c9361e91a904050df01133f61b0817e267a1b2dc66786ea391bf343149d10d2e5c2273e20aeb6047b2c07c886c8bd1197eee5ec701a92d947dea4728d0d4f986a5d020a89d394e415fc6949e040c0a7437c214faa30e6e77a3b435b2bcce944314d38f60fc31f277a988ba1057072aa1fe31443ed9923a6af391cff8e5556a41bdf6795f4e23a09851850e7d523d768d21ccc51df1b5ff29d4d2810d3b5659dc50e3305736ebbb81a923c07c32a72732fc8313a70fd22011691ada34fb513c784c35bc65c5e60b024555328983a4b7c02a2eb9df99474c25404f598b7b188c3212335ab5e87f2938ff8f6273d7e51ccb7962c029beae5cc4aa414f9b911c32a7c71ce95bfba36fda7c17765acf8c614d0a6612f6d835a35768a9277b2f3c20b5c2f3fe7ae65277c1b6c779e78effa4f23527c7ffc87ed620ff27a01d8fe556e586a4a5f9094c0ecdb9fdb9e5824d61e7c6c4d287a8a43096b647dd84a47e8c4b849a2ccc6b876c039a4caa069c2db612d0ce2f0902be601e8b1cebe44c9893714182a6e89c52c51681d2549cda3ee117e14ffdb4a350ce40bad51531c60675511c96222a6128395390e4b93f09e0f60dda55f04820a91c0004b4b0142e676020b062f8b083459fc0709a58ddea1c3f32ecc6697eaa65b5fcdc48a51d7130cb85c573ce785d5708448d62650f597c6625150edadf74b7bcbc3d418261312c58ac3428962a251cefa043cdf9d6e1b24fd85cc8fc3e4238aadf86f9f553115ea4168fd6ff2190c28dc8a861f08704f0d65f19e69c87fcaf8a28d2740adf4ad7c90ef0d6685b37d960319ca7e81758713f7d07c46aa23e33188e7f4b0ac347a24172e99cc6ee012db73231b4e851e552c266870b8dd7d4b178e5d8838cc7f33e0c878498fd5ed102778d32ea7312089fec381c922878bd611c071cc477ac5b61d490749556ecfd3f1f4b3bbd905516a521995d5700027b5f7ce2ac436ad71115bdbf1389c07fa1a86c461c7e62214af6fddd5ab505a31f4b1674bd8701add057ff3b3dc2ce4471a76cda1db05b4abff3b5ea8bd43fa165a56c163033ee1594467118e899318de12a0a836be97cd20b2ce48257867283e3d320d68c8712e70d1552ea6f5f09a6ac964ae6f3e6608062c39f6cca1d51931a044e7df6d87c5e0cecdb11e2a52429b01f097b4313394af87bbce2663a242612df88ee1c2a8d26a958ca55b5a5fe9c8c2b1e5a530eaef0e4320df766c9097a5415d1918103d7e4c8dccb4d06230b53af01f89e840b950db1d33e6d3020c96d225e19abeb1adea949e3068bebd3499188841176647833496f8f5185d22c111a4cede2f4999b0a1aa5ce1742bda5dc5e38f7d88edc35802191c6ea7022f38f27fc2ee9288b208a52fa43ed072be554c50a6b494fc1f33612e6b3a7c66b1201e1e3bf80fd4a497cf02aee675b4b20d356a5bd4b7fa8828228803f16987c2c7cb6950820d0acbc3650a1f3909f0882720e841ec169fd46b1a1da35d872576a7466bd3b1df2669e0757eb1a99170dc180953eae3b2dcae0108e0b6aa568ba2e031699cac26fcf2f70e65b15cda8d9cea678c1f7535fa8d0babd54b12bc3f560688b2865244c4483c1cb918bee777d22dfe9a654ca270dc0d59b0bb7aed7395b868bae0f847dc290d767564d4e218cc7b41f9d578d27e3769845538480fa175dadb15378d173502fee009cbbfae750c1144bca380f60d899b1ccbe760d9636b3670563efe932fdec6f222513982fef5c7490177cfd4b27ca09124d6a71dc35b4f9d95ecdfd66d7be4a5f0476c172d9c0eebc7547e53fe3465b886906301146cbaec39c5577dd7710fbcff3e5b42d3062127cb7d1a763aaa6ac2eba4a0f22bf450ebef7e8c7641420d9afe4cec803ca74fb409c5d1ad29dea673e3d9069476c597b2848e2f5a84b098e481eeb46ad520ee7f0bc32e3544dc9be25892e167743db344eca1268dc66922885aa3bcb3383aa77b95c2dfdad36fc2adf166beb7ca8945fb9e2a2632c71b53843b0bafe7d4bc345f2f24471378d2e33c9110b3f3996e9d10fb2ac06ab9034d58b73c2391f92bc5c68550c47f8f629063d10a57733e0309d70417fed507bb64b2f4571ffcd3ea95767e61431bd8fef1e293973abdfa47f47f742456a4f5a3c632abbba1fc72c13bff335d091e1dc86fd80a5eb05fb604021fccacd6c910ae48f39cba4849399c2845533a2e753102656d0e16742f2ae73faeee16b28d209c862b0712f6d312b20316ce6a387a8a46d4c5c4b56a2e9183d837a583871489011216808d750cbabf96290d3b5cf0651e04f40f658af24a3813bdc8f067af2fe39994bd7c3cc380a67ed68ce44e4e1302aa7b28721335df27bb6785e52319c3e8750401ff5dc41143e628c4c38ebaa86020e5caebc236ee3bac0aa1e57d9309aa21d5dd1cc9488f6abb53d187dcad7ebf1652347ed479e5f892f854fd2db385e466f03241b3c432f7219c374e10c81f73ac9a35659cff259f9487c62a1433898206cf0324e9ec61a55f4f7d6fa3dfc8be2b4d0ddc98b5999c81f4f5e739c31e0536495ec8b4064c67a40c5a1e9601beac0188138bd23dd379536a432b2c84b0885cf07ee7d92807d64db8b8c500325d6c5d36f8089a1154e923545d273307009d8394457023c3845c9e202eeef74ce31e30105bcf88daf5b5b5cedc091cbf1d8fe1d2a941c02b443833e7e7c013ea6fc858b489adb8a8f257b3951c159240971c44d3e84187fb9002dfe6641a01cad6891087bf9c9d28eaf302a69b74a58788918b92f54da64c07f285b101f1104a80107445dff544b326d01929e120acb9747ab8154de2b712805a6914341d9d750594a17c52c3c1abdde85948c618f0ce88a286d69dfa17a5c94841c032110d78c434d5fc442e28b94b16f3977f95b5d93452ed0531a851f2448ac96a7fc55f3cfa430a540ab330bf0b30c41652e623d9c0d5eade5146a9257000c80506fd0bd2913253fc91e2be13335c068502a23ff1af5c0bd70ee4f0e5646acfb992e19d81ebe312214234c3f51b5ade504ab5a36f76fac1cfea8529d1277003c755d41dfbd0c8c3261881ade97299d9db9521ae0230befe9d8917a35bb4b18b72d5c7f89754849bfa0ac1c2299660283fbc03dc3be49da37e575b728ba3ebc5448114d5610ac11b250a5a05130101cbf071e790d41703104a675342722a7786c28e36acafd012d38d082d1dee8823dfb1169a2fda672a08c1df104ca70ee3c07c95ee45258cf10c382478f2105a37fe3eed1e5915b30353fb2576a3b67e14503afd38eb8482d5c15819ac290d2661b17ca29a9f4c809ffcd791bbeeb090a6af458ef1003bcd1d4bddbdfdca0c6a9a11dc87405e66ced7f261db9227ac9ae64b1df5586b5247786c5cce1059e8fbab7f52787f3f9efb82d0c784683e337fc3bae919f6c0a3cf4c5c11e50224f05ef10dd2056a00708dce80b169a0d8fc609dfb7952728a3b7711c2719123e8eb6a91558fd545d8c6d0f1dc03dc7b7215061935dbfea3e653268fce88aebe4d9a766f0a4c9e20318c9687b2f45cc0149714903f30a462e47b1f8096c8acbcb702c16ea743a6cfd78a22a2cfe447317ac47d55932164700ccfac4f3cecd3a00ad914e155269f4d891ba8f9ff199f68efe105bd54a70e0d23efaf2be1ed3bd586772eb54ce856bbca13c2d01ad3ff765938d7fb4a84a3304f8bfeb5499edb241d06110b980689c9b09ef7f1b0bacd21f23c44a280c38789b71eddc20866f74d7a72202cd1714a1f56be63b7c925b25f72a0b6b4cb403ab71b3a6250201c6575a4775e2e872e144b2e9c38d42450ff0f555146c3d6772a77227b7fdb495b6124956264eb7929de1c0060a3d6d9e5aa9da452518e42eca8c2a5ee3e223ff4f11974396470298b765bbe912c84960a7b142e259f802d11a1ae22a7386f9654dfc942829190e10763cb26feb0848415da3ffff38a337e9d337fb40b75ac9307bc73b0301ab3a7283f468d81b192ed8f77072fbd54f33d794c2d626a294662c1e1ae7aeab9d9b28d35c9647c6928fade87016c5e930032eaf33690b80c0469b3097de5bdb7a11bd2771e08ede7e5405496864f943d1c606ce0b74c8f166747b9ee00a68a2d4a433b06693fdb17afeb4b08cc256b62d1d99a09a380e386fe0b238ff7f1a8ff86bf53e0a8c84f98a5635bfb87dde193acfb62c63ffb7a338e5eca7338c4ee58fb0ca0ef3c4663e7f9e52b121df673b09051a56a3e713084e1a622004cc14571aa625e85896a7f0595941afa6d0f51aa35275831f297f6eae0f05aacc4dd40a74349d97f22bba0807daab3ebe710bdd6ab197b7e512c","link":"/posts/27073/"},{"title":"Mac上Haskell的安装环境搭建","text":"Mac上Haskell的换源和安装 参考文章：vscode搭建haskell环境 参考文章针对的是旧版本的stack，本文针对较新版本的stack stack stack官方安装指导 Installing GHC automatically, in an isolated location.Installing packages needed for your project.Building your project.Testing your project.Benchmarking your project 正如官网所说，直接安装stack的好处是它自带Haskell的编译器GHC和Cabal(a system for building and packaging Haskell libraries and programs)等Heskell运行需要文件(个人觉得stack类似anaconda，环境管理+包管理工具)。但是国内安装不换源的话，搭建之路会很不顺利 使用brew安装stack 1brew search haskell 可以看到brew返回了两个结果，一个是Formulae下的haskell-brew，另一个是Cask类型下的haskell-for-mac，后者是个IDE，使用brew cask install haskell-for-mac下载，但是下载的过程太长，不知道到底是什么样，我们还是按照教程里的方法下载stack 1brew install haskell-stack 换源 这个时候如果按照stack官网的指示 12345stack new my-projectcd my-projectstack setupstack buildstack exec my-project-exe 很可能卡在setup步骤 第一种错误是返回Connection Failure，开全局VPN也没用那种。根据我在stackOverflow查到的信息，主要原因可能是路由器认为该地址是不良链接，拒绝了访问，无脑解决方法是直接手机开热点 第二种错误是执行stack setup之后一直卡在ghc-8.8.2: dowanload has begun其实就是原本的下载源在国外，所以下载速度起不来，所以我们要换清华的镜像源 要换的源涉及两个文件：~/.cable/config ~/.stack/config.yaml 首先换stack(stackage镜像使用帮助)和stack setup(hackage镜像使用帮助)的源，stack版本在2.1.1以上和以下不一样，这里只写2.1.1以上版本： 打开~/.stack/config.yaml，加上： 1234567891011121314151617181920setup-info: \"http://mirrors.tuna.tsinghua.edu.cn/stackage/stack-setup.yaml\"urls: latest-snapshot: http://mirrors.tuna.tsinghua.edu.cn/stackage/snapshots.jsonpackage-indices: - download-prefix: http://mirrors.tuna.tsinghua.edu.cn/hackage/ hackage-security: keyids: - 0a5c7ea47cd1b15f01f5f51a33adda7e655bc0f0b0615baa8e271f4c3351e21d - 1ea9ba32c526d1cc91ab5e5bd364ec5e9e8cb67179a471872f6e26f0ae773d42 - 280b10153a522681163658cb49f632cde3f38d768b736ddbc901d99a1a772833 - 2a96b1889dc221c17296fcc2bb34b908ca9734376f0f361660200935916ef201 - 2c6c3627bd6c982990239487f1abd02e08a02e6cf16edb105a8012d444d870c3 - 51f0161b906011b52c6613376b1ae937670da69322113a246a09f807c62f6921 - 772e9f4c7db33d251d5c6e357199c819e569d130857dc225549b40845ff0890d - aa315286e6ad281ad61182235533c41e806e5a787e0b6d1e7eef3f09d137d2e9 - fe331502606802feac15e514d9b9ea83fee8b6ffef71335479a2e68d84adc6b0 key-threshold: 3 # number of keys required # ignore expiration date, see https://github.com/commercialhaskell/stack/pull/4614 ignore-expiry: no 现在换cabal的源 在终端执行cabal update后Ctrl+C停止, 然后进行下一步。报错没关系，这一步的目的是生成~/.cabal/config配置文件 打开~/.cabal/config ，加入 12repository mirrors.tuna.tsinghua.edu.cn url: http://mirrors.tuna.tsinghua.edu.cn/hackage 为了速度，可以将官方仓库注释掉。实际有朋友反应他的配置文件中本身就没有官方仓库这一行 12-- repository hackage.haskell.org -- url: http://hackage.haskell.org/ 现在可以愉快地按照stack官方安装指导 中的步骤继续了 12345 stack new my-project cd my-projectstack setup stack buildstack exec my-project-exe 或者像python一样在终端运行.hs文件 123runhaskell filename# 或者runhs filename Hs学习笔记&lt;–To be Continued–&gt; https://www.w3cschool.cn/hsriti/","link":"/posts/32573/"},{"title":"mac快捷键和常用命令行","text":"mac常用命令行，快捷键。以及其他系统软件的使用技巧 命令行和快捷键隐藏文件 显示隐藏文件： 12defaults write com.apple.Finder AppleShowAllFiles YESKillAll Finder 不显示隐藏文件： 12defaults write com.apple.Finder AppleShowAllFiles NOKillAll Finder 快捷键方式：command+shift+. 截图 修改截图默认文件名 12defaults write com.apple.screencapture name &quot;Screenshot&quot;killall SystemUIServer 更换默认截图路径 12defaults write com.apple.screencapture location ~/Desktop/屏幕截图killall SystemUIServer 去掉窗口截图的阴影 12defaults write com.apple.screencapture disable-shadow -bool truekillall SystemUIServer ssh免验证 有的时候配置了ssh服务，比如VPS远端登录，比如github账号，但是每次使用都会出现Enter passphrase for key '/Users/apple/.ssh/id_rsa'要求输入本地根用户密码—-这和密码登录有什么区别! 原因就是虽然在本地生成了ssh-key，但是没有把key添加到本地用户列表里。使用以下命令即可 1ssh-add -k /Users/apple/.ssh/id_rsa 表情符号control+command+space Automator相关批量将word/ppt转换为pdf删除重复文件批量压缩图片 事实上，不建议使用automator的批量压缩图片，因为不容易控制图片的像素。ps的录制存储图片为web所用格式的动作后批处理文件比较省心","link":"/posts/8410/"},{"title":"markdown进阶使用技巧","text":"markdown中的mermaid作图, html结合等进阶使用的handbook 页内跳转 两种方法究其根本都是md中html语法的应用 1.生成目录方法 123* [页内跳转](#link_in_page) * [1生成目录的方法](#link_in_page.1) * [2html标签实现](#link_in_page.2) 生成效果: 页内跳转 1.生成目录的方法 2.html标签实现 在正文中对应的地方, 加入章节标题对应id 1&lt;h2 id='link_in_page'&gt;页内跳转&lt;/h2&gt; 2.html标签实现 定义一个锚在跳转的目的地 &lt;span id = &quot;jumptoexample&quot;&gt;页内跳转&lt;/span&gt; 在要需要跳转的地方使用md语法的超链接 [ 点击跳转 ](#jumptoexample) 点击跳转","link":"/posts/64578/"},{"title":"Linux终端的基本命令","text":"Linux终端入门手册 shell 提示符username@hostname:direction$ shell命令格式command [option] [arguments] 按一次tab补全文件名按两次tab补全命令单击右键粘贴 基本命令 帮助命令 man 查看man手册 info 查看info手册 —help 目录 根目录 / .代表目录自己 ..代表目录的父目录，对于根目录.和..都代表自己 pwd 查询当前目录路径 ～ 引用当前用户的主目录 绝对路径/home/hxy/hello.txt 相对路径./hello.txt 文件与目录相关命令 ls 显示目录内容 ls -la 列出所有文件，包括隐含文件 ls -dl 仅查看目录属性 ls -R 递归显示子目录的文件 ls 文件名/文件夹名 查看文件信息 ls -l 详细结果 详细结果：drwx------ 14 student student 409611...第一个字符表示文件类型：-普通文件 d目录 l符号链接 b块设备文件 c字符设备文件后面9个字符表示文件的访问权限： 第一组表示文件属主的权限 第二组表示同组用户的权限 第三组表示其他用户的权限各权限如下 r 读 w 写 x 执行，对于目录表示进入 cd 切换工作目录 cd .. 进入上一级目录 cd ~ 或 cd 进入用户主目录 mv [options] 源文件/文件夹 目标文件/文件夹 cp 复制文件或目录 cp -a 拷贝目录，保留一切链接和属性 cp -f 覆盖已经存在的目标文件而不提示 cp -R 递归复制目录下的所有字目录和文件 mkdir 创建一个目录 mkdir -m 对新建目录设置存取权限（chmod） mkdir -p 自动补全不存在的上级目录 rmdir 删除空目录 rmdir -p 递归删除目录 rm 删除 rm -r 递归删除（等同rmdir） rm -i 删除一个文件 rm -f 不询问，直接删除 file 确定文件类型 cat 链接或显示文件内容 带行数 cat -n 等价于nl tac 从最后一行开始显示文件内容 more/less head/tail touch 新建文件 nl 按输出行号的方式显示文件 ln 为一个文件在另一个位置建立符号链接 ln -s 目标 目录 软连接，一个指向源文件名的连接文件，类似快捷方式 ln 目标 目录 硬连接 类似指针 字符 grep 定位字符信息 wc 统计字符信息 sort 排序字符信息 打包/压缩文件 打包：把所有文件合并在一个tar文件里 压缩 使用gzip(tar.gz/tgz)或biz2(tar.bz2)压缩.gz比较快，压缩率不如bz2 -c 创建tar文件 -f将文件打包生成到一个文件 tar -cf new.tar ./home/se tar -xf new.tar 解包 对于zip格式：tar cvzf 打包 tar xvzf解包 对于biz2格式： tar cvjf 打包 tar xvjf解包 用户管理及网络设置GCC编译器gcc支持的源码格式：.c .cpp .m（Objective-C源程序） .i（预处理后的c文件） .ii（预处理后的c++文件） .s/.S（汇编语言源程序） .h（预处理器文件） .o（目标文件） gcc的基本使用单个源码 gcc hello.c -o hello 把hello.c编译成一个可执行程序hello（一次性完成四步） gcc hello.c不指定输出名，生成一个a.out 源文件到可执行文件的编译过程： 预处理 gcc -E hello.c -o hello.i 编译：将源代码编译成汇编代码 gcc -S hello.i -o hello.s 汇编：将汇编代码汇编成目标文件 gcc -c hello.s -o hello.o 链接：将目标代码和所需要库链成一个完整的应用程序 gcc hello.o -o hello gcc的结果输出于后缀名，只和输出参数有关 多个源码 一般先将源代码编译成目标代码，最后一次链接成可执行程序 对于有头文件在多个目录，需要在编译时多次使用-I参数加入头文件所在目录例如a.c需要用到/usr，当前目录/homegcc -I -I/usr -I/home -c a.c 对于多个源文件组成的程序。可以把多个文件在一句里编译，但建议不这样做，建议使用makefile脚本来调用gcc构造，见下一节gcc a.c b.c d.c -o test gcc的选项 宏macro -Dmacro gcc test.c -DPRINTF=printf -o test -Dmacro=defn gcc test.c -DNUM=10 -o test gcc -Wall a.c -o a打开所有编译警告 gcc -Wall -Werror a.c -o a将警告视作错误，出现任何警告就放弃编译 gcc -w禁止输出警告 gcc使用的第三方库gcc命令的参数详解 -x：设定文件名所使用的语言，使文件后缀名无效 gcc -x c hello.pig -c：只进行预处理,编译和汇编，即生成.o的obj文件 gcc -c hello.c -S：只进行预处理和编译，即把文件编译为.s汇编代码 gcc -S hello.c -E：只激活预处理。这个命令不会不生成文件, 我们需要把它重定向到一个输出文件里面 gcc -E hello.c &gt; pianoapan.txt -o：生成可执行文件 gcc -o hello hello.c -fno-asm -fno-strict-prototype -fthis-is-varialble -fcond-mismatch -funsigned-char 、-fno-signed-char、-fsigned-char 、-fno-unsigned-char -include file -imacros file b Makefilemake的调用 直接执行make，自动查找当前目录下名为makefile的文件，并自动从第一个target开始执行 如果makefile脚本名称不是缺省名称，使用-f参数来表示make -f hello.mk 如果需要make查找其他目录下的makefile，使用-C参数make -C /home 在makefile中以target表示不同的编译部分，可以在命令行直接写target名称，用于一个活多个target的编译make installmake target1 target2 makefile的格式makefile由由一组依赖关系和规则构成 每个依赖关系由一个目标（即将要创建的文件）和它依赖的源文件组成 规则描述了怎样从源文件创建出目标文件 规则也称为target 规则 目标名称：[依赖对象]&lt;tab&gt;命令列表 目标名称是需要创建的结果的名称 依赖对象表示创建这个目标之前必须预先创建的其他目标，可以是另一个规则的名称，也可以是基本文件的名称 命令列表表示为了创建这个目标，需要执行那些shell命令可以是一行或多行shell命令，每一行命令行的行首必须是一个tab 行首必须是tab不能是空格，否则makefile出错 如果命令行过长，可用\\分行，新行无需tab打头123456# 要想生成hello.o目标，必须先有hello.c，然后调用gcc编译生成hello.o，依赖对象hello.c可以省略hello.o: hello.c gcc -c hello.c -o hello.o# 要想生成执行程序hello，必须先执行规则hello.o，然后调用命令行gcc连接生成hellohello: hello.o gcc hello.o -o hello makefile里规则的前后顺序不太重要，实际调用顺序取决目标之间的依赖关系，因此make采用逆推的方式来判断和执行目标* 伪目标phony target：一般的目标最终是为了生成一个文件，但有一些目标可以不生成结果文件，只是为了调用命令或依赖对象，具体动作需要需要开发者自行编写 all 编译所有目标 clean 清楚项目生成的中间文件和最终生成文件 install 项目如何安装 uninstall 项目如何卸载 makefile基本结构makefile一般包含： 需要由make工具创建的项目，通常是目标文件和可执行文件，它们一般被称为target 要创建的目标依赖于哪些文件 创建每个目标时需要运行的的命令，命令之间用tab打头 通常包含的固定伪目标 #表示注释行1234567891011#Makefile for exp2main: main.o add.o del.o modify.o gcc -o main main.o add.o del.o modify.omain.o: main.c gcc -c main.cadd.o: add.c gcc -c add.cdel.o: del.c gcc -c del.cmodify.o: modify.c gcc -c modify.c makefile扩展用法 变量（宏）：利用简单的变量定义冗长的编译选项，引用时需要添加$符号1234567# Define macros for name of compiler CC = gcc# Define a macro for the CC flags CCFLAGS = -D_DEBUG -g -m486# A rule for building a object file test.o: test.c test.h $(CC) -c $(CCFLAGS) test.c makefile变量定义，=两边一定要有空格 makefile的变量定义要独立在规则之外，一般在最前 GNU make的预定义变量 $&lt; 第一个依赖文件的名称 $@ 目标的完整名称 $^ 所有的依赖文件，以空格分开，不包含重复的 AR 归档维护程序的名称，默认值ar ARFLAGS 归档维护程序的选项 AS 汇编程序的名称，默认值as ASGLAGS 汇编程序的选项 CC c编译器的名称，默认值cc CCFLAGS c编译器的选项 1234567891011#makefile2 for expmain: main.o add.o del.o modify.o gcc -o $@ $^main.o: main.c gcc -c $&lt;add.o: add.c gcc -c $&lt;del.o: del.c gcc -c $&lt;modify.o: modify.c gcc -c $&lt; 自动化变量使用12345#makefile2 for expmain: main.o add.o del.o modify.o gcc -o $@ $^.c.0: gcc -c $&lt; 隐含规则GNU make的一些内置的隐含规则定义了如何从不同依赖文件建立特定类型的目标文件 后缀规则suffix rule将一个具有某个后缀的文件转换为具有另一后缀的文件12.c.0: $(CC) $(CCFLAGS) -c -o $@ $&lt; 模式规则pattern rules在目标的前面多一个%，同时可用来定义目标和依赖文件之间的关系12%.o:%.c: $(CC) $(CCFLAGS) -c -o $@ $&lt; makefile目标编译如果不指定目标，make会默认第一个target规范的makefile文件有以下常见的几个目标： make all 编译所有目标 make clean 在编译结束后删除.o文件 make install 编译结束后将最终的可执行文件安装到系统的某一个位置12345678910#makefile for exampleexample: example.o add.o modify.o delete.o $(CC) -o $@ $^.c.o: $(CC) -c $&lt;all: exampleclean: all rm -f *.oinstall: clean cp example /usr/local/bin GDB调试器和调试方法gdb的使用为使程序能被调试，需要gcc编译时用-g选项为程序编译时添加调试信息gcc -g -o helloworld helloworld.c然后在命令行键入gdb并回车就可以运行了 gdb命令 file 装入想要调试的可执行文件。 kill 终止正在调试的程序。 list 列出产生执行文件的源代码的一部分。 next 执行一行源代码但不进入函数内部。 step 执行一行源代码而且进入函数内部。 run 执行当前被调试的程序。 c 继续运行程序。 quit 终止gdb。 watch 使你能监视一个变量的值而不管它何时被改变。 backtrace 栈跟踪，查出代码被谁调用。 print 查看变量的值。 make 使你能不退出gdb就可以重新产生可执行文件。 shell 使你能不离开gdb就执行UNIX shell命令。 whatis 显示变量或函数类型。 break 在代码里设断点，这将使程序执行到这里时被挂起。 break linenum 根据行号设置断点 break funcname 根据函数名设置断电 break filename:linenum/funcname 执行非当前源文件的某行或某函数的时候停止执行 break linenum/funcname if expr 根据条件停止程序执行 info break 显示当前断点清单，包括到达断点处的次数等。 info files 显示被调试文件的详细信息。 info func 显示所有的函数名称。 info local 显示当函数中的局部变量信息。 info prog 显示被调试程序的执行状态。 delete [n] 删除第n个断点。 disable[n] 关闭第n个断点。 enable[n] 开启第n个断点。 ptype 显示结构定义。 set variable 设置变量的值。 call name(args) 调用并执行名为name，参数为args的函数。 Finish 终止当前函数并输出返回值。 return value 停止当前函数并返回value给调用者。 GTK","link":"/posts/55266/"},{"title":"编译原理与设计-Lab1-语言认知实验","text":"分别使用 C/C++、Java、Python 和 Haskell 实现快速排序和归并排序算法，对采用这几种语言实现的编程效率，程序的规模，程序的运行效率进行对比分析。 1 实验目的和内容 实验目的：了解程序设计语言的发展历史，了解不同程序设计语言的各自特点;感受编 译执行和解释执行两种不同的执行方式，初步体验语言对编译器设计的影响，为 后续编译程序的设计和开发奠定良好的基础。 实验内容： 分别使用 C/C++、Java、Python 和 Haskell 实现快速排序算法和归并排序，对采用这几种语言实现的编程效率，程序的规模，程序的运行效率进行对比分析。 实验说明：实验使用电脑参数如下 2 实验的具体过程和步骤 实验分三组： 普通情况(50000个范围在1~100000的不重复数)下不同语言的归并排序和快速排序 最坏情况： 小规模组(1000-&gt;1逆序排列) 大规模组(10000-&gt;1逆序排列) 快速排序的算法采用三数取最小数的算法，平均时间复杂度 $ O(nlogn) $ ，最坏时间复杂度 $ O(n^2) $ 归并排序无论最好最坏情况，时间复杂度均为 $ O(nlog_2n) $ 不同语言所使用的的算法完全一致，时间函数分别使用各语言提供的库函数 C语言 编译器版本及运行环境 123 $ gcc --version Apple clang version 11.0.0 (clang-1100.0.33.17)Target: x86_64-apple-darwin19.3.0 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#define N 1000 //50000为实验1规模，10000为实验2-1规模，1000为实验2-2规模#define O 2 //1为装填out.txt中的数据，2为装填逆序数组//归并函数void Merge(int *num, int start, int mid, int end){ int *temp = (int *)malloc((end-start+1) * sizeof(int)); int i = start; int j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= end){ if (num[i] &lt;= num[j]){ temp[k++] = num[i++]; } else { temp[k++] = num[j++]; } } while (i &lt;= mid){ temp[k++] = num[i++]; } while (j &lt;= end){ temp[k++] = num[j++]; } for (i = 0; i &lt; k; i++){ num[start + i] = temp[i]; } free(temp);}//归并排序void MergeSort_UptoDown(int *num, int start, int end){ int mid = start + (end - start) / 2; if (start &gt;= end) { return; } MergeSort_UptoDown(num, start, mid); MergeSort_UptoDown(num, mid + 1, end); Merge(num, start, mid, end);}//分解函数int partition(int arr[], int low, int high){ int key; key = arr[low]; while(low&lt;high){ while(low &lt;high &amp;&amp; arr[high]&gt;= key ) high--; if(low&lt;high) arr[low++] = arr[high]; while( low&lt;high &amp;&amp; arr[low]&lt;=key ) low++; if(low&lt;high) arr[high--] = arr[low]; } arr[low] = key; return low;}//快速排序void quick_sort(int arr[], int start, int end){ int pos; if (start&lt;end){ pos = partition(arr, start, end); quick_sort(arr,start,pos-1); quick_sort(arr,pos+1,end); } return;}//装填函数int fill(int arr[]){ if(O==1){ int cnt = 0; FILE *fp = NULL; fp = fopen(\"/Users/apple/Downloads/out.txt\",\"r\"); char buff[10]; while(fscanf(fp,\"%s\",buff)!=EOF){ arr[cnt++]=atoi(buff); } return cnt; } else{ for (int i = 0; i &lt; N; ++i) { arr[i] = N - i; } return N; }}int main(){ int arr[N+1]; int num = fill(arr); struct timeval begintime,endtime; gettimeofday(&amp;begintime, NULL); quick_sort(arr , 0 , num-1); gettimeofday(&amp;endtime, NULL); printf(\"Size-%d / \", num); printf(\"Qsort-C Running Time : %ld ms\\n\",1000*(endtime.tv_sec-begintime.tv_sec)+(endtime.tv_usec-begintime.tv_usec)/1000); num = fill(arr); gettimeofday(&amp;begintime, NULL); MergeSort_UptoDown(arr , 0 , num-1); gettimeofday(&amp;endtime, NULL); printf(\"Size-%d / \", num); printf(\"Mergesort-C Running Time : %ld ms\\n\",1000*(endtime.tv_sec-begintime.tv_sec)+(endtime.tv_usec-begintime.tv_usec)/1000);} 使用gcc编译器生成可执行文件： 1gcc -o lab1_c lab1.c 在终端运行可执行文件6次 1/.lab1_c Java 编译器版本及运行环境 123456 $ Javac --version javac 10.0.2 $ java --version openjdk 10.0.2 2018-07-17 OpenJDK Runtime Environment 18.3 (build 10.0.2+13)OpenJDK 64-Bit Server VM 18.3 (build 10.0.2+13, mixed mode) 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import java.io.*;public class Lab1 { static int O = 2; //1为装填out.txt中的数据，2为装填逆序数组 static int N = 10000; //50000为实验1规模，10000为实验2-1规模，1000为实验2-2规模 public static void fill(int[] arr){ if (O==1) { int cnt =0; String pathname = \"/Users/apple/Downloads/out.txt\"; try (FileReader reader = new FileReader(pathname); BufferedReader br = new BufferedReader(reader) ){ String line; while ((line = br.readLine()) != null) { arr[cnt++]=Integer.parseInt(line); } }catch (IOException e) { e.printStackTrace(); } } else{ for (int i=0; i&lt;N; i++) { arr[i] = N-i; } } } public static void main(String[] args){ print5(); } public static void print5(){ int[] arr = new int[N]; fill(arr); long t = System.currentTimeMillis(); // System.out.println(arr[0]+\" \"+arr[N/2]+\" \"+arr[N-1]); quick_sort(arr,0 , N-1); // System.out.println(arr[0]+\" \"+arr[N/2]+\" \"+arr[N-1]); System.out.println(\"QSort-Size-\"+N+\" / Java Running time : \"+(System.currentTimeMillis()-t)+\" ms\"); fill(arr); // System.out.println(arr[0]+\" \"+arr[N/2]+\" \"+arr[N-1]); t = System.currentTimeMillis(); m_sort(arr,0 , N-1); // System.out.println(arr[0]+\" \"+arr[N/2]+\" \"+arr[N-1]); System.out.println(\"MergeSort-Size-\"+N+\" / Java Running time : \"+(System.currentTimeMillis()-t)+\" ms\"); } //分解函数 public static int partition (int []arr, int low, int high){ int key; key = arr[low]; while(low&lt;high){ while(low &lt;high &amp;&amp; arr[high]&gt;= key ) high--; if(low&lt;high) arr[low++] = arr[high]; while( low&lt;high &amp;&amp; arr[low]&lt;=key ) low++; if(low&lt;high) arr[high--] = arr[low]; } arr[low] = key; return low; } //快速排序 public static void quick_sort(int []arr, int start, int end){ int pos; if (start&lt;end){ pos = partition(arr, start, end); quick_sort(arr,start,pos-1); quick_sort(arr,pos+1,end); } return; } //归并排序 public static int[] m_sort(int[] a,int low,int high){ int mid = (low+high)/2; if(low&lt;high){ m_sort(a,low,mid); m_sort(a,mid+1,high); //左右归并 merge(a,low,mid,high); } return a; } //合并函数 public static void merge(int[] a, int low, int mid, int high) { int[] temp = new int[high-low+1]; int i= low; int j = mid+1; int k=0; // 把较小的数先移到新数组中 while(i&lt;=mid &amp;&amp; j&lt;=high){ if(a[i]&lt;a[j]){ temp[k++] = a[i++]; }else{ temp[k++] = a[j++]; } } // 把左边剩余的数移入数组 while(i&lt;=mid){ temp[k++] = a[i++]; } // 把右边边剩余的数移入数组 while(j&lt;=high){ temp[k++] = a[j++]; } // 把新数组中的数覆盖nums数组 for(int x=0;x&lt;temp.length;x++){ a[x+low] = temp[x]; } }} 使用java编译器(javac.exe)编译为字节码文件(.class) 1javac Lab1.java 运行生成的字节码文件6次 1java Lab1 python 解释器版本 12$ python --versionPython 2.7.16 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import timeimport syssys.setrecursionlimit(100000)O = 1 //1为装填out.txt中的数据，2为装填逆序数组N = 50000 //50000为实验1规模，10000为实验2-1规模，1000为实验2-2规def merge(arr, l, m, r): n1 = m - l + 1 n2 = r- m L = [0] * (n1) R = [0] * (n2) for i in range(0 , n1): L[i] = arr[l + i] for j in range(0 , n2): R[j] = arr[m + 1 + j] i=0 j=0 k=l while i &lt; n1 and j &lt; n2 : if L[i] &lt;= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i &lt; n1: arr[k] = L[i] i += 1 k += 1 while j &lt; n2: arr[k] = R[j] j += 1 k += 1 def mergeSort(arr,l,r): if l &lt; r: m = int((l+(r-1))/2) mergeSort(arr, l, m) mergeSort(arr, m+1, r) merge(arr, l, m, r) def partition(arr,low,high): key = arr[low] while(low&lt;high): while low&lt;high and arr[high] &gt;= key: high-=1 if low&lt;high: arr[low] = arr[high] low+=1 while low&lt;high and arr[low]&lt;=key: low+=1 if low&lt;high: arr[high] = arr[low] high -= 1 arr[low] = key return lowdef q_sort(arr,start,end): if start&lt;end: pos = partition(arr,start,end) q_sort(arr,start,pos-1) q_sort(arr,pos+1,end) return arrdef quick_sort(arr): return q_sort(arr,0,len(arr)-1)def do(): if(O==1) arr=[] #直接使用out.txt内数据初始化 else for x in xrange(1,N): arr[i]=N-x; begintime=time.time() quick_sort(arr) endtime = time.time() Running_time = (endtime-begintime)*1000 print(\"Qsort-python Running time : %f ms\"%Running_time) begintime=time.time() mergeSort(arr,0,len(arr)-1) endtime = time.time() Running_time = (endtime-begintime)*1000 print(\"Msort-python Running time : %f ms\"%Running_time)arr = [0]*Ndo() 在终端运行6次 1python lab1.py Haskell 解释器版本 12$ runhaskell --versionrunghc 8.8.2 源代码 12345678910111213141516171819202122232425262728293031323334353637383940import Text.Printfimport Control.Exceptionimport System.CPUTimemsort :: (Ord a) =&gt; [a] -&gt; [a]msort [] = []msort [x] = [x]msort xs = merge (msort xs1) (msort xs2) where k = (length xs) `div` 2 xs1 = take k xs xs2 = drop k xs merge :: (Ord a) =&gt; [a] -&gt; [a] -&gt; [a] merge [] b = b merge a [] = a merge a@(x:xs) b@(y:ys) | x &gt;= y = x:(merge xs b) | otherwise = y:(merge a ys)qsort :: (Ord a) =&gt; [a] -&gt; [a]qsort [] = []qsort (x:xs) = qsort [i | i &lt;- xs, i &gt;= x] ++ [x] ++ qsort [i | i &lt;- xs, i &lt; x]main=do start &lt;- getCPUTime let list =msort [] --实验1直接填入out.txt中数组，实验2-1为[1..1000]，实验2.2为[1..10000] let a = maximum list printf \"Size %d \"(a::Int) end &lt;- getCPUTime let diff = (fromIntegral (end - start)) / (10^9) printf \"qsort Haskell Running time: %0.3f ms\\n\" (diff :: Double) start &lt;- getCPUTime let list =qsort [] --实验1直接填入out.txt中数组，实验2-1为[1..1000]，实验2.2为[1..10000] let a = maximum list printf \"Size %d \"(a::Int) end &lt;- getCPUTime let diff = (fromIntegral (start - end)) / (10^9) printf \"msort Haskell Running time: %0.3f ms\\n\" (diff :: Double) 在终端运行6次 1runhaskell lab1.hs 3 运行效果截图1 常规组 50000个范围在1~1000000的不重复数 C 快速排序平均运行时间：6.00 ms 归并排序平均运行时间：13.33 ms JAVA 快速排序平均运行时间：14.00 ms 归并排序平均运行时间：16.33 ms python 快速排序平均运行时间：88.26 ms 归并排序平均运行时间：244.45 ms Haskell 因为笔者失误，此处Size应为50000，msort和qsort对应时间输出交换，即第一行为qsort运行时间，第二行为msort运行时间 快速排序平均运行时间：504.93 ms 归并排序平均运行时间：416.71 ms 2-1 小规模最坏数据 对逆序数组[1000,999,998,997,996,995,…,4,3,2,1]进行升序排列 C 快速排序平均运行时间：1 ms 归并排序平均运行时间：0 ms Java 快速排序平均运行时间：3.5 ms 归并排序平均运行时间：0.83 ms python 快速排序平均运行时间：26.24 ms 归并排序平均运行时间：3.51 ms Haskell 因为笔者失误，msort和qsort对应时间输出交换，即第一行为qsort运行时间，第二行为msort运行时间 快速排序平均运行时间：309.12 ms 归并排序平均运行时间：3.285 ms 2-2大规模最坏数据 对逆序排列[10000,9999,9998,9997,9996,9995,…,4,3,2,1]进行升序排列 因为Haskell较易生成正序列表，所以对于Haskell对正序排列[1,2,3,4…9999,10000]进行降序排列 C 快速排序平均运行时间：97.17 ms 归并排序平均运行时间：1.6 ms Java 快速排序平均运行时间：45.67 ms 归并排序平均运行时间：4.67 ms Python 快速排序平均运行时间：2595.45 ms -&gt; 2.6s 归并排序平均运行时间：41.71 ms Haskell 因为笔者失误，msort和qsort对应时间输出交换，即第一行实为qsort运行时间，第二行为msort运行时间 快速排序平均运行时间：31378.91 ms -&gt; 31.4s 归并排序平均运行时间：38.00 ms 4 语言易用性和程序规模对比分析1 语言易用性1 学习难度Python&lt;=Java&lt;=C&lt;&lt;Haskell 语言 难度分析 C C作为大多数人编程的入门语言，先声夺人，字符串处理文件处理数组初始化等等基础操作，大多时候我都更习惯c的写法。链表与指针和内存管理是C的一大难以逾越的障碍 Java Java的语法大致类似C/C++，并且没有C中令人头疼的链表指针和内存操作，有自动内存管理，个人认为学过C再加上对面向对象的理解是非常容易上手Java的 Python Python近年被广泛推崇为儿童编程的入门语言，不一定说明它很简单，但至少说明它入门容易。Python中缩进作为格式化使得程序总体更简洁，但也使得在大项目中它的可维护性降低。Python更适合于小型项目，或者玩具，例如跑一个CNN。 Haskell 习惯了命令式语言，面对Haskell这样的纯函数式语言会陷入完全的不知所措。它是一种不同的概念、一种新的语言范式。需要用与我们的习惯所不同的方式开发应用，不同的方式组织应用，不同的方式扩展应用 2 语言的编程效率个人认为编程分为两部分：初始编码+Debug 对于几种主流语言编程效率的普遍看法认为，python是效率最高的，C次之，Java最为啰嗦繁琐，而函数式编程语言较少用于工程。但我个人的经历里，不同语言在不同项目规模下各有所长。大型项目大多基于Java的相关框架，如果开发一个移动互联应用(上万行)，Java几乎可以说是没有敌手，它的啰嗦和繁琐减小了奇奇怪怪的bug发生的可能性，而在Java下继续前进还有Korlin，Swift等专门为应用开发而设计的语言。C/C++适合于开发小型项目(几千行)，比如小游戏或者解释器，使用C开发能够在某种程度上方便开发者最大程度提升程序的运行效率。至于Python，个人认为Python适合千行以内的代码规模，目前的学习中使用到Python的地方主要是人工智能和知识工程等课程，一个神经网络大致也就一百行代码，Python的相关库Numpy和TensorFlow在神经网络的应用中已经非常成熟。尽管Python在初始编码阶段能优雅简洁的一行代码完成一个复杂的功能，但在debug阶段Python也能让人一个头有两个大。使用Python中稍不注意就会有缩进造成的bug，怎么检查都难以寻觅其踪迹，可想如果代码规模稍大，该有多么头疼。 至于函数式编程，其思想和命令式编程有很大的不同。有人说，大部分人第一次使用Haskell或Ocaml时都完全的不知所措。在Haskell里，连分号都跟别人不一样。这并不是语法的问题；Haskell和ML语言完全基于一种不同的概念、一种新的语言范式。需要用不同的方式开发应用，不同的方式组织应用，不同的方式扩展应用。所以说它入门门槛高，适用范围不广，但是学界非常喜欢，其在数学逻辑证明上的优势是其他语言望尘莫及的。而非纯函数编程语言，如Lisp，其历史悠久，也曾在相关历史时期居于某些领域(人工智能)的统治地位。 总而言之，在不同的战场上使用相适合的工具是决定编程效率的关键。而就本次实验中的编程效率来说，仅仅实现一个快排算法，C，Java和Python并无太大差别，有差别也主要是个人对于不同语言熟练性造成的，Haskell的描述函数是什么而不是命令机器怎么做的优势高下立现，程序规模是其他的一半(统计见表4-3) 3 程序规模Python&gt;=C&gt;Java&gt;&gt;Haskell 语言 快排总代码行数 实现快排函数行数 归并排序总代码行数 实现归并函数行数 C 46 24 41 41 Java 37 25 38 38 Python 46 21 45 45 Haskell 17 4 11 11 5 程序运行性能对比分析 (统一保留到小数点后一位) 快速排序 语言 常规组平均运行时间$O(nlogn)$ 小规模最坏组平均运行时间$(O(n^2))$ 大规模最坏组平均运行时间$(O(n^2))$ C 6.0 ms 1.0 ms 96.0 ms Java 14.0 ms 2.4 ms 41.8 ms Python 88.3 ms 24.5 ms 2396.9 ms Haskell 504.9 ms 284.4 ms 45812.2 ms 在常规组和小规模最坏组的实验中，符合常规的认知，效率上C最优，Java次之；对于解释型语言，Python较快，Haskell非常耗时，尤其是在n为较大值的时间复杂度(O(n^2))下 在大规模最坏组的实验中，Java比C快了一半。猜测Java在递归过程中编译器进行了优化，因为本实验未涉及几种语言的内存使用测量，故作出此猜测。 归并排序 语言 常规组平均运行时间$O(nlogn)$ 小规模组平均运行时间$O(nlogn)$ 大规模组平均运行时间$O(nlogn)$ C 13.33 ms 0.3 ms 1.6 ms Java 16.3 ms 0.8 ms 4.7 ms Python 244.5 ms 3.5 ms 41.7 ms Haskell 416.7 ms 3.2 ms 38.0 ms 归并排序是一种稳定排序，对于最好/最坏/平均都有 $ O(nlogn) $ 复杂度，在实验中确实可以得到体现；效率上以上是C最优，Java次之；对于解释性语言，常规组(规模50000) 在小规模组(规模1000)和大规模组(规模10000)的实验中，可以看到Haskell比Python有了细微的优势。但在常规组(规模50000)的实验中，python又超过了Haskell。笔者另外增加了规模80000和100000的测试： 80000规模python归并排序5次平均运行时间：374.1 ms； 80000规模haskell归并排序5次平均运行时间：477.3 ms; 100000规模python归并排序5次平均运行时间：474.1 ms; 100000规模haskell归并排序5次平均运行时间：588.2 ms; 可以看出随着数据规模增大，python又较haskell具有了优势。 6 实验心得体会 我想，大多数人的对编程语言的学习都有一个刚入门时遇到一些困难，然后逐渐轻松，云开日朗，但是之后又遇到一个巨大的瓶颈，有可能是诸如指针这样的概念，也有可能是无关语法的对算法的理解限制住了编程能力的提高。差不多所有学过编程的人都有过遇到困难的经历。我们在学了一些基本知识后，必然会遇到一些公认的概念上的关口，比如指针。很少人能轻松的掌握它们。大多数人，比如我，则需要不断的练习和参考例子来理解什么是指针、为什么它们很重要。 对于同一种思维方式的语言，如命令式语言，一旦学会几种语言后，所有的语言都开始看起来都很相似，虽然有细微差别，但入门都会相对容易。做移动互联的大作业的时候，Dart、Swift或者Kotlin的语法，它们都存在共通的地方；开发个人博客的时候，利用掌握的html我们也能把Jade、ejs的代码改得更符合我们的需求。Python的人学习Ruby可能不会遇到太多的问题，知道Java的人学习C#会感到很熟悉。不错，也有意外的地方。Ruby爱好者在学习Python时会对它的comprehension感到吃惊，Java用户会对C#里的委托摸不着头脑。还是那句话，如果只瞟一眼，它们都很相似。 但是第一次使用Haskells时我陷入了不知所措。看官方代码的一头雾水和无论如何都无法让自己的程序正确运行的焦灼不安。这并不是语法的问题；Haskell和ML语言完全基于一种不同的概念、一种新的语言范式。需要用不同的方式开发应用，不同的方式组织应用，不同的方式扩展应用。而我还是习惯性的在haskell中输入let list = quicksort [1..10]这样的命令，期望它运行。很多这样的新概念都具有不可思议的强大力量。Haskell里的Monads是跟指针一样基础且强大的概念。所以，跟学了Java后再学C#不一样，有志向学习函数式语言的人需要往回走的更远，去学习更加基础的概念后才能接下去学习。就像是完全再学习一次 说说细节上的收获，在进行大规模的实验时，我发现python、Java和Haskell都有对递归深度限制，但是C几乎是完全自由没有任何限制的。在运行速度上，解释执行的Python和Haskell自然无法与编译执行的C和Java比， Java虚拟机的启动占用一定的时间，所以在数据规模增后的快排实验中，Java要比C快了一半。","link":"/posts/53125/"},{"title":"编译原理与设计-Lab2-编译器认知实验","text":"GCC编译器和LLVM编译器的编译过程以及效率对比 实验目的和内容本实验主要的内容为在 Linux 平台上安装和运行工业界常用的编译器 GCC 和 LLVM，如果系统中没有安装，则需要首先安装编译器，安装完成后编写简单的测 试程序，使用编译器编译，并观察中间输出结果。 实现的内容与方法 本机环境： 系统masOS Catalina，已安装homebrew 1 编译器安装1234# 安装gcc8brew install gcc@8# 安装clangxcode-select --install 2 编写测试程序 单个程序 1234#include &lt;stdio.h&gt;int main(){ printf(\"hello\\n\");} 多个程序 cal.c 12345678#include &lt;stdio.h&gt;int add(int a,int b);int main(){ int num1, num2; scanf(\"%d %d\",&amp;num1,&amp;num2); int res = add(num1,num2); printf(\"%d\\n\", res);} add.c 1234 #include \"add.h\" int add(int num1, int num2){ return num1+num2;} 3 运行编译器进行观测GCC 查看编译器版本 12gcc -v$ gcc version 8.3.0 (Homebrew GCC 8.3.0_2) 使用gcc编译单个文件 1gcc -o hello hello.c 使用gcc编译链接多个文件 1gcc -o cal cal.c add.c 查看预处理结果 1gcc -E hello.c -o hello.i 查看语法分析树 1gcc -fdump-tree-all hello.c 生成的文件列表，使用ls -ltr 查看(按生成顺序倒序排列) 查看中间代码生成结果 1gcc -fdump-rtl-all hello.c 生成的文件列表，使用ls -ltr 查看(按生成顺序倒序排列) 查看生成的目标代码(汇编代码) 1gcc -o hello.asm -S hello.c LLVM 查看编译器的版本 1clang -v 返回结果 1234Apple clang version 11.0.0 (clang-1100.0.33.17)Target: x86_64-apple-darwin19.3.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 使用编译器编译单个文件 1clang -o hello hello.c 使用编译器编译链接多个文件 1clang -o cal cal.c add.c 查看编译流程和阶段 1clang -ccc-print-phases test.c -c 终端的输出： 查看词法分析结果 1clang test.c -fsyntax-only -Xclang -dump-tokens 查看词法分析结果 2: 1clang test.c -fsyntax-only -Xclang -dump-raw-tokens 生成的结果： 查看语义分析结果 12clang test.c -Xclang -ast-dump # error linkclang -fsyntax-only -Xclang -ast-dump test.c 部分结果： 查看语义分析结果 2 12clang test.c -Xclang -ast-view # clang: error: linker command failed with exit code 1 clang test.c -fsyntax-only -Xclang -ast-view # 因为缺乏gv环境 此命令未能得到成功结果 部分结果： 查看编译优化的结果: 1clang test.c -S -mllvm -print-after-all 部分结果： 查看生成的目标代码结果 Target code generation 1clang –S test.c 生成的目标代码文件开头： 运行结果分析 GCC 运行结果分析 GCC进行编译的大概步骤： 词法分析 –&gt; 语法分析 –&gt; 生成语法树 –&gt; 高级gimple –&gt; 低级gimple –&gt; cfg –&gt; ssa –&gt;RTL –&gt;目标代码(汇编代码) GENERIC、GIMPLE和RTL三者构成了gcc中间语言的全部，它们以GIMPLE为核心，由GENERIC承上，由RTL启下，在源文件和目标指令之间的鸿沟之上构建了一个三层的过渡。 预处理结果 运行gcc -E hello.c –o hello.i，将会产生 hello.i 文件，这就是 hello.c 经过预处理后的文件。原本4行的程序，经过预处理，得到了580行的预处理文件 预处理文件开头： 预处理文件结尾： 可以看到， hello.c 经过预处理后得到的 hello.i文件，除了原本的几行代码之外，还包含了很多额外的变量、函数等等，这些都是预处理器处理的结果。 语法分析树 运行gcc -fdump-tree-all hello.c后，一共生成了22个文件，其命名格式均为filename.c.&lt;num&gt;t.name 分析这22个文件内容(顺序为生成的先后顺序)： 046t.profile_estimate/318t.statistics为空白； 007t.lower/010t.eh相同； 012t.ompexp/013t.printf-return-value1/019t.fixup_cfg1相同； 020t.ssa/027t.fixup_cfg3/029t.einline/088t.fixup_cfg4/222t.veclower/223t.cplxlower0/225t.switchlower/232t.optimized相同 028t.local-fnsummary1/050t.local-fnsummary2相同 其余还有004t.gimple/006t.omplower/011t.cfg /049t.release_ssa 不与其他相同 以下重点对比源文件与004t.gimple/010(即007t.lower)/013的区别，其排序与生成顺序一致 main函数转变为高端gimple的过程 ：004t.Gimple GCC 利用 “gimplifier” 将 GENERIC 中间表示转换为 GIMPLE中间表示。 语法树到高端gimple的转化是以语法树的节点为单位进行遍历的 以函数为单位进行转化，并且将函数内部的所有变量以及编译器为方便生成运行时结构所创建的临时变量都提高到函数最开始的位置，为计算栈空间和使用寄存器提供依据 将函数执行语句集中到一起，并且其顺序与语法树种所表现的顺序一致，为配合运行时结构会增减一些语句 return语句转低端gimple的处理：007t.lower/010t.eh： GIMPLE中有一个lower的动作，用于将高层次的GIMPLE表示，解析成低层次的，这个lower动作在pass_lower_cf中完成。 高端gimple到低端gimple主要完成数据合并，代码合并和返回语句合并，有利于最后生成更规整的后端代码 在gimple_return语句的位置插入一条goto lable跳转语句 将gimple_return语句暂存起来，将gimple语句序列中的gimple_return语句删掉 待所有的语句都lower gimple转换完之后，再将gimple_return语句做gimple_return的处理，处理过程是先添加一个标号，以便于第一句的goto lable对应上，然后再把return 语句插入gimple语句序列 经过以上处理得到的低端gimple已经足以支持生成最终的目标代码，确定运行时结构了，但是gcc考虑到优化，在此基础上转化了cfg和ssa结构 低端gimple到cfg结构中间代码：012t.ompexp/013t.printf-return-value1/019t.fixup_cfg1 GCC设计cfg ( control flow graph ) 主要是用于函数内部的控制流转化，跨函数间的逻辑优化由于逻辑比较复杂，GCC目前还没有完成 cfg的主要作用是在低端gimple的基础上将语句分成几个基本块(basic block)，在基本块内，代码是顺序执行的，不存在跳转语句，如果有跳转语句，则放在块的最后，保证跳转只发生在块与块之间，即在gimple中，指令跳转的语句就是基本块的边界 013t与之后生成的hello.c.019t.fixup_cfg1/hello.c.027t.fixup_cfg3内容一致。相比007t.lower/010t.eh，语句被划分为几块，goto语句被取代。 cfg转ssa：020t.ssa 为每个变量增加一个版本号，用于数据流的优化，它的结构是跟低端gimple的结构相同的 如下cfs1与ssa的对比，变量int下多了一个版本号 中间结果及目标代码 考虑到平台的通用性，gcc生成了一套通用的RTL结构，将在RTL的基础上转化为目标代码 使用gcc -fdump-tree-all hello.c 查看生成的中间结果 生成RTL 由于GCC是支持多种平台的，在不同的平台上生成的汇编代码的格式肯定是不同的，如果为每个平台的汇编代码都写一套优化逻辑，是不太现实的，为了解决这个问题，GCC提供了一种中间形式的汇编语言RTL(Register Transfer Language)，它与具体的平台无关，这样所有的优化都可以基于RTL了，在所有的优化完成之后，再转变成针对不同硬件平台的汇编代码，每一条RTL语句称为一条insn语句 转化为RTL阶段的主要步骤 转化为初始的RTL 明确初始的RTL中的运行时结构信息，此时把虚拟寄存器更新为真实的寄存器 RTL生成目标代码，也就是汇编代码，gcc -o hello.asm -S hello.c 查看 LLVM 运行结果分析 查看编译流程和阶段clang -ccc-print-phases test.c -c 返回的结果 0：获得源代码main.c，c语言文件 1：预处理阶段，做相应处理 2：编译阶段 3：步骤通过后端进行汇编前的处理 4：汇编阶段 5：链接阶段，做相应处理通过如上步骤可以了解到整个过程以及过程中的一些信息。例如首先进行的预处理操作可以使用如下命令查看具体信息： 预处理阶段 clang -E test.c 这个过程包括宏的替换，头文件的导入等等 词法分析 在此步骤会把代码切成一个个Token，比如大小括号，等于号还有字符串等。 1234# 词法分析1clang -fsyntax-only -Xclang -dump-tokens test.c# 词法分析2clang test.c -fsyntax-only -Xclang -dump-raw-tokens 图片中依次为词法分析1，词法分析2和源文件 可以看到，-dump-raw-tokens仅仅输出我们编写的test.c的词法分析结果，而-dump-tokens输出还包括所有头文件的词法分析结果 语法分析 验证程序的语法是否正确，然后将所有的节点组成抽象语法树AST 1234# 语法分析1clang -fsyntax-only -Xclang -ast-dump test.c# 语法分析2clang test.c -fsyntax-only -Xclang -ast-view # 因为缺乏gv环境 此命令未能得到成功结果 下图依次是语法分析1得到的抽象语法树ast，语法分析2的得到的语法树生成图的源文件。test.c的源代码 这些步骤完成之后就要开始进行IR中间代码的生成了，代码生成器CodeGen会负责将语法树自顶向下遍历逐步翻译成LLVM IR，IR就是编译过程的前端的输出以及后端的输入；此步骤LLVM会去做些优化工作，在Xcode的编译设置里也可以设置优化的级别-01，-03，-0s等； 1234# 查看生成的IR中间代码clang -S -fobjc-arc -emit-llvm main.m -o main.ll# 查看LLVM编译优化的结果clang test.c -S -mllvm -print-after-all 下图依次为中间代码，LLVM编译优化的结果 生成汇编文件clang –S test.c 下图左为源文件，右为生成的汇编代码 GCC 与 LLVM 对比分析源文件均为C语言的hello world 下图左为gcc生成的汇编文件，右为llvm生成的汇编文件 优化编译 gcc提供了从O0-O3以及Os这几种不同的优化级别供大家选择 O0： 不做任何优化，这是默认的编译选项。 -O和-O1： 对程序做部分编译优化，对于大函数,优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。 -O2： 是比O1更高级的选项，进行更多的优化。Gcc将执行几乎所有的不包含时间和空间折中的优化。当设置O2选项时，编译器并不进行循环打开（）loop unrolling以及函数内联。与O1比较而言，O2优化增加了编译时间的基础上，提高了生成代码的执行效率。 -O3： 比O2更进一步的进行优化。在包含了O2所有的优化的基础上，又打开了以下优化选项： -finline-functions：内联简单的函数到被调用函数中。由编译器启发式的决定哪些函数足够简单可以做这种内联优化。默认情况下，编译器限制内联的尺寸，3.4.6中限制为600（具体含义不详，指令条数或代码size？）可以通过-finline-limit=n改变这个长度。这种优化技术不为函数创建单独的汇编语言代码， 而是把函数代码包含在调度程序的代码中。 对于多次被调用的函数来说, 为每次函数调用复制函数代码。 虽然这样对于减少代码长度不利, 但是通过最充分的利用指令缓存代码, 而不是在每次函数调用时进行分支操作, 可以提高性能。 -fweb：构建用于保存变量的伪寄存器网络。 伪寄存器包含数据, 就像他们是寄存器一样, 但是可以使用各种其他优化技术进行优化, 比如cse和loop优化技术。这种优化会使得调试变得更加的不可能，因为变量不再存放于原本的寄存器中。 -frename-registers：在寄存器分配后，通过使用registers left over来避免预定代码中的虚假依赖。这会使调试变得非常困难，因为变量不再存放于原本的寄存器中了。 -funswitch-loops：将无变化的条件分支移出循环，取而代之的将结果副本放入循环中。 优化编译测试文件采用Lab1中的快速排序代码 GCC优化编译 规模为50000的1000000以内的不重复随机数(算法效率$O(log_n))$ 规模为50000的逆序排列(算法效率$O(n^2)$) 每组实验重复5次，最后运行时间取平均数，单位为ms 优化方式 O(logn) O(N^2) -O0 6 2830 -O1 3 505.4 -O2 4 835 -O3 3 567 gcc四种优化编译效率对比 LLVM优化编译 规模为50000的1000000以内的不重复随机数 规模为50000的逆序排列 每组实验重复5次，最后运行时间取平均数，单位为ms 优化方式 O(logn) O(N^2) -O0 6 2368 -O1 3 567 -O2 3 574 -O3 3 556 llvm四种优化编译效率对比 GCC与LLVM优化编译效果对比 可以看出，总体而言，llvm优化效率是优于gcc的 面对快排这样的少循环多递归的情况，-O2的优化效率是不如-O1和-O3的 实验心得体会 了解工业界常用的编译器 GCC 和 LLVM。以前我对编译器之前的区别并没有比较明确的认知，这此实验之后我才知道macOS系统里的gcc命令实际上调用的是clang命令； 熟悉编译器的安装和使用过程。本次实验的过程较实验1曲折了很多，过程中也遇到了很多波折，虽然很多波折是与实验本身无关的—-比如安装GCC编译器需要把下载源换为国内的tuna/USTC；wget brew等软件包管理工具，在下载软件不成功的时候会尝试下载软件的源代码，然后在本地编译； 了解编译器的优化效果。本次实验并不是我们第一次接触gcc命令，以前我们学习过了基础的gcc命令参数，怎么进行gdb调试，以及makefile的写法；通过本次实验，我终于又系统了解了一遍gcc命令的相关参数的作用，进一步了解了编译优化； 观察编译器工作过程中生成的中间文件的格式和内容。本次实验中，我进一步了解了GCC编译器编译的全过程，以及这些过程存在的原因。gcc编译的过程有词法分析 –&gt; 语法分析 –&gt; 生成语法树 –&gt; 高级gimple –&gt; 低级gimple –&gt; cfg –&gt; ssa –&gt;RTL –&gt;目标代码(汇编代码)。低端gimple已经足以支持生成最终的目标代码，确定运行结构了，但是gcc考虑到优化，还在此基础上转化了cfg和ssa结构。RTL结构是gcc为了平台的通用性而生成的一套通用的RTL结构，最终在RTL的基础上转化为汇编代码。 本次实验进一步为我们对编译器的学习和构造奠定了基础。","link":"/posts/673/"},{"title":"编译原理与设计-Lab3-词法分析实验","text":"使用ANTLR自动生成词法分析器 实验目的和内容根据 C 语言的词法规则，设计识别 C 语言所有单词类的词法分析器的DFA。并使用 Java，利用ANTLR自动生成词法分析器。。词法分析器的输入为 C 语言源程序，输出为属性字流。 实验过程与方法实现词法分析的功能，首先需要了解实验提供的编译器的使用方法和实现架构，实验提供的BITMiniCC 是以Java为实现语言实现的C语言编译器，此次实现的词法分析功能属于编译器的前端功能词法分析一般是以预处理的结果为基础进行的，但是由于BIT-MINICC框架的预处理部分存在缺陷，所以本次实验中跳过了预处理部分。 1 框架 从 github 下载 BIT-MINICC 框架，导入IntelliJ或Eclipse; 在test/scanner_example.c中，输入提供的testFile.c作为测试源代码；更改config.xml config.xml1234- &lt;phase skip=\"false\" type=\"java\" path=\"\" name=\"preprocess\" /&gt;- &lt;phase skip=\"false\" type=\"java\" path=\"\" name=\"scan\" /&gt;+ &lt;phase skip=\"true\" type=\"java\" path=\"\" name=\"preprocess\" /&gt;+ &lt;phase skip=\"false\" type=\"java\" path=\"bit.minisys.minicc.scanner.AWScanner\" name=\"scan\" /&gt; lib下已有antlr包，省去导入的过程 2 编写语法按照C11标准编写C.g4文件。参考ANTLR官方的C Grammar语法规范文件 开首grammar C; C必须与文件名C.g4一致 然后是一些形如规则名 : 分支1 | ... | 分支N ;的规则，一段文本匹配规则相当于它匹配其中一个分支，分支中可用单引号包围要按字面匹配的字符串、用子规则名表示按子规则匹配，另外还可用一些类似正则表达式的记号如?、*、+、|和() 语法规则名以小写字母开始，不同语法规则生成解析树不同类型的结点，各分支说明这种结点的子结点序列可以是什么样子 词法规则名以大写字母开始，不同词法规则生成不同语类的词，各分支说明这类词可以是什么样子 以fragment 开首的规则可以被词法规则引用以便重用代码，但本身不会生成对解析器可见的词 3 生成解析器 在intelliJ中下载ANTLR v4 grammar plugin 添加C.g4语法文件，在列表中右键点击该语法文件，选择生成ANTLR，configure选项可以编辑生成文件的输出地址。 在gen.bit.minisys.minicc.scanner目录下，得到生成的解析器。其中分词器CLexer(以下仅给出部分)。其最后 CLexer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// Generated from /Users/apple/Downloads/lab3/BIT-MiniCC-master/src/bit/minisys/minicc/scanner/C.g4 by ANTLR 4.8package gen.bit.minisys.minicc.scanner;import org.antlr.v4.runtime.Lexer;import org.antlr.v4.runtime.CharStream;import org.antlr.v4.runtime.Token;import org.antlr.v4.runtime.TokenStream;import org.antlr.v4.runtime.*;import org.antlr.v4.runtime.atn.*;import org.antlr.v4.runtime.dfa.DFA;import org.antlr.v4.runtime.misc.*;@SuppressWarnings({\"all\", \"warnings\", \"unchecked\", \"unused\", \"cast\"})public class CLexer extends Lexer { static { RuntimeMetaData.checkVersion(\"4.8\", RuntimeMetaData.VERSION); } protected static final DFA[] _decisionToDFA; protected static final PredictionContextCache _sharedContextCache = new PredictionContextCache(); public static final int T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, T__9=10, T__10=11, T__11=12, T__12=13, T__13=14, Auto=15, Break=16, Case=17, Char=18, Const=19, Continue=20, Default=21, Do=22, Double=23, Else=24, Enum=25, Extern=26, Float=27, For=28, Goto=29, If=30, Inline=31, Int=32, Long=33, Register=34, Restrict=35, Return=36, Short=37, Signed=38, Sizeof=39, Static=40, Struct=41, Switch=42, Typedef=43, Union=44, Unsigned=45, Void=46, Volatile=47, While=48...; public static String[] channelNames = { \"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\" }; public static String[] modeNames = { \"DEFAULT_MODE\" }; private static String[] makeRuleNames() { return new String[] { \"T__0\", \"T__1\", \"T__2\", \"T__3\", \"T__4\", \"T__5\", \"T__6\", \"T__7\", \"T__8\", \"T__9\", \"T__10\", \"T__11\", \"T__12\", \"T__13\", \"Auto\", \"Break\", \"Case\", \"Char\", \"Const\", \"Continue\", \"Default\", \"Do\", \"Double\", \"Else\", \"Enum\", \"Extern\", \"Float\", \"For\", \"Goto\", \"If\", \"Inline\", \"Int\", \"Long\", \"Register\", \"Restrict\", \"Return\", \"Short\", \"Signed\", \"Sizeof\", \"Static\", \"Struct\", \"Switch\", \"Typedef\", \"Union\", \"Unsigned\", \"Void\", \"Volatile\", \"While\", \"Alignas\", \"Alignof\", \"Atomic\", \"Bool\"... }; } public static final String[] ruleNames = makeRuleNames(); private static String[] makeLiteralNames() { return new String[] { null, \"'__extension__'\", \"'__builtin_va_arg'\", \"'__builtin_offsetof'\", \"'__m128'\", \"'__m128d'\", \"'__m128i'\", \"'__typeof__'\", \"'__inline__'\", \"'__stdcall'\", \"'__declspec'\", \"'__asm'\", \"'__attribute__'\", \"'__asm__'\", \"'__volatile__'\", \"'auto'\", \"'break'\", \"'case'\", \"'char'\", \"'const'\", \"'continue'\", \"'default'\", \"'do'\", \"'double'\", \"'else'\", \"'enum'\", \"'extern'\", \"'float'\", \"'for'\", \"'goto'\", \"'if'\", \"'inline'\", \"'int'\", \"'long'\", \"'register'\", \"'restrict'\", \"'return'\", \"'short'\", \"'signed'\", \"'sizeof'\", \"'static'\", \"'struct'\", \"'switch'\", \"'typedef'\", \"'union'\", \"'unsigned'\", \"'void'\", \"'volatile'\", \"'while'\", \"'_Alignas'\", \"'_Alignof'\", \"'_Atomic'\", \"'_Bool'\", \"'_Complex'\", \"'_Generic'\", \"'_Imaginary'\", \"'_Noreturn'\", \"'_Static_assert'\", \"'_Thread_local'\", \"'('\", \"')'\", \"'['\", \"']'\", \"'{'\", \"'}'\", \"'&lt;'\", \"'&lt;='\", \"'&gt;'\", \"'&gt;='\", \"'&lt;&lt;'\", \"'&gt;&gt;'\", \"'+'\", \"'++'\", \"'-'\", \"'--'\", \"'*'\", \"'/'\", \"'%'\", \"'&amp;'\", \"'|'\", \"'&amp;&amp;'\", \"'||'\", \"'^'\", \"'!'\", \"'~'\", \"'?'\", \"':'\", \"';'\", \"','\", \"'='\", \"'*='\", \"'/='\", \"'%='\", \"'+='\", \"'-='\", \"'&lt;&lt;='\", \"'&gt;&gt;='\", \"'&amp;='\", \"'^='\", \"'|='\", \"'=='\", \"'!='\", \"'-&gt;'\", \"'.'\", \"'...'\" }; } private static final String[] _LITERAL_NAMES = makeLiteralNames(); private static String[] makeSymbolicNames() { return new String[] { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, \"Auto\", \"Break\", \"Case\", \"Char\", \"Const\", \"Continue\", \"Default\", \"Do\", \"Double\", \"Else\", \"Enum\", \"Extern\", \"Float\", \"For\", \"Goto\", \"If\", \"Inline\", \"Int\", \"Long\", \"Register\", \"Restrict\", \"Return\", \"Short\", \"Signed\", \"Sizeof\", \"Static\", \"Struct\", \"Switch\", \"Typedef\", \"Union\", \"Unsigned\", \"Void\", \"Volatile\", \"While\"... }; } private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames(); public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES); /** * @deprecated Use {@link #VOCABULARY} instead. */ @Deprecated public static final String[] tokenNames; static { tokenNames = new String[_SYMBOLIC_NAMES.length]; for (int i = 0; i &lt; tokenNames.length; i++) { tokenNames[i] = VOCABULARY.getLiteralName(i); if (tokenNames[i] == null) { tokenNames[i] = VOCABULARY.getSymbolicName(i); } if (tokenNames[i] == null) { tokenNames[i] = \"&lt;INVALID&gt;\"; } } } @Override @Deprecated public String[] getTokenNames() { return tokenNames; } @Override public Vocabulary getVocabulary() { return VOCABULARY; } public CLexer(CharStream input) { super(input); _interp = new LexerATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache); } @Override public String getGrammarFileName() { return \"C.g4\"; } @Override public String[] getRuleNames() { return ruleNames; } @Override public String getSerializedATN() { return _serializedATN; } @Override public String[] getChannelNames() { return channelNames; } @Override public String[] getModeNames() { return modeNames; } @Override public ATN getATN() { return _ATN; } public static final String _serializedATN = public static final ATN _ATN = new ATNDeserializer().deserialize(_serializedATN.toCharArray()); static { _decisionToDFA = new DFA[_ATN.getNumberOfDecisions()]; for (int i = 0; i &lt; _ATN.getNumberOfDecisions(); i++) { _decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i); } }} 4 调用词法解析器在src/bit/minisys/minicc/scanner目录下，新建AWScanner.java AWScanner是IMiniCCScanner的一种实现 输入输出文件和字符流(使用system.out打印的内容将全部输出到文件outputFile中 12345678// 传入函数的是预处理过后的文件名String outputFileName = MiniCCUtil.removeAllExt(fileName) + MiniCCCfg.MINICC_SCANNER_OUTPUT_EXT;// 输出文件File outputFile = new File(outputFileName);outputFile.createNewFile();FileOutputStream outFileOutputStream = new FileOutputStream(outputFile);PrintStream localPrintStream = new PrintStream(outFileOutputStream);System.setOut(localPrintStream); 调用Clexer词法分析器 123456789101112CharStream stream = CharStreams.fromFileName(fileName, Charset.defaultCharset());CLexer lexer = new CLexer(stream);CommonTokenStream tokens = new CommonTokenStream(lexer);tokens.fill();for (Token tok : tokens.getTokens()) { if ( tok instanceof CommonToken) { System.out.println(((CommonToken)tok).toString(lexer)); } else { System.out.println(tok.toString()); }} 输出文件 运行效果1 testFile运行结果 实验心得体会 本次实验中加深对 C 语言的词法规则的了解，了解了编译器词法分析器的主要功能和实现技术 进一步了解 Flex 工作原理和基本思想，学习如何使用 Antlr 自动生成词法分析器 本次实验中初步了解了到词法分析模块与其他模块之间的交互过程","link":"/posts/62214/"},{"title":"编译原理与设计-Lab4-文法设计实验","text":"阅读C11-C规范标准文件并按照规范选择C语言子集，使用BNF文法描述。 下载C11-C规范标准文件 下载Java SE12规范标准文件 实验内容 阅读附件提供的 C 语言和 Java 语言的规范草稿，了解语言规范化定义 应包括的具体内容。 选定 C 语言子集，并使用 BNF 表示方法文法进行描述，要求至少包括 表达式、赋值语句、分支语句和循环语句；或者设计一个新的程序设计语言，并 使用文法对该语言的词法规则和文法规则进行描述。 实验过程与方法本次实验提供 C 语言和 Java 语言的规范草稿，参考相关内容完成语言的设计和定义工作。此外，可以使用 ANTLRWorks 辅助完成语法的设计工作。 理解语言规范 语言标准规范是每个语言的说明文档，定义了语言的字符集、词法规则、语法规则和语义规则，也包括了对程序结构、编译过程、标准库程序以及语言实现等各方面的内容。一个标准规范描述为不同视角的参与者提供了一个一致的参考标准，例如程序员可以根据规范标准编写程序，系统设计者则可以根据这一标准 规范设计编译器、完成运行时环境和库的构造和实现。由于编译器基于同一标准 规范设计，因此才能对程序员编写完成的各式各样的程序进行不同层面验证，并 将其最终翻译为目标代码。同理，所有的程序设计人员都基于同一个标准设计程 序，按照给定的接口调用库函数，因此大家才能交换共享并理解对方的代码，并协同工作完成大规模软件项目的开发。 C语言提出之后呢，随着技术的不断发展，曾经衍生过不同的版本，也就是C语言的不同标准规范。这里我们使用C11-C标准规范来分析。、语法规则和语义规则，也包括了对程序结构、编译过程、标准库程序以及语言实现 语言的字符集。字符集是一个语言中所有可出现字符的集合。C11-C的P40页(chap 5.2)中，给出了可使用的字符集合，并将它们分为两类：，，这两个字符集由各自被分为和。字符集是设计分割源代码的有限自动机的基础； 语言的词法规则。P76(chap6.4 Lexical element)开始，给出了所有词法元素： 词法分析中的token：关键字； 预处理的token：头文件名，标识符，pp-number，字符常量，字符串字面量、分隔符和任何不能匹配上述规则的非空白字符 语言的语义规则：P94(chap6.5~6.10)：给出详细的语义规则。 这份规范中甚至还给出了对C语言未来发展方向的指导。 首先定义了语言的字符集。字符集是该语言中所有可出现字符的集合。而且将字符集分为了源代码字符集(source character set)和运行字符集 (execution character set)两种，分别在C语言源码和执行程序中使用，同时两个字符集还被分为基本字符集和 拓展字符集 阅读关于一个程序设计语言的标准是一件非常痛苦的事情，C11-C标准规范的正文的长度大约有670页，阅读这样一份标准确实需要很多的时间。但这份规范所包涵的内容极广，无论是语言书写者阅读还是为语言设计提供参考都是一份和好的材料。 在C11-C标准规范的p476开始，给出了C语言的句法规范总结Language syntax summary 。我们使用BNF描述C语言，依据的正是这个规范总结，规范总结中对于C语言的描述大概是下面这样: 这个描述的意思是，对于分支语句，一共有三种格式，，。并且这个描述在语法上对每个格式里各部分组成进行了明确定义。之后按照语法规则得到的结构又被分割为一个个的token和词法分析。这就是一个分支语句。 在C语言的标准规范中不仅仅针对语言本身，更明确了C语言源代码到转译为可执行程序的每一步，以及每一步里的数据结构，转换方法、存储进行了严格说明。C语言规范保证了语言的严谨性，尽力消除歧义。但这份规范中也存在较为宽泛的问题。比如说数据类型，它定义 long型数据长度不短于 int 型，short 型不长于 int 型。这会导致对于 int 型的变量，在 Turbo C 里面它占16位。 然而在VC 里面，一个整型变量却占有32位。在不同的开发平台上关于整型变量的定义不同，导致相同的程序在不同的编译器上运行 可能会有不同的解释 从而造成相同的程序在不同的平台上的运行结果也有可能是不同的。 C语言文法设计报告字母表123456# 非数字 Nondigits a..z|A..Z# 数字 Digits 0..9# 29个符号： !\"#%&amp;'()*+,-./: ;&lt;=&gt;?[\\]^_{|}~ 语法规则 使用ANTLR文法描述方法 以下将使用ANTLR文法描述C语言的语法规则。ANTLR输入文法是一种扩展的 BNF 表示方法。以下的文法规则并不完整，和的文法较为庞杂，在此不表。 语法分析的终结符一共有5种：关键字/标识符/字符串字面量/常量/分隔符及运算符，即词法分析得到的5种token。 1234567891011121314151617181920// 文法分析入口translationUnit : externalDeclaration | translationUnit externalDeclaration ;externalDeclaration : functionDefinition | declaration | ';' // stray ; ;// 语句类型statement : labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement | ('__asm' | '__asm__') ('volatile' | '__volatile__') '(' (logicalOrExpression (',' logicalOrExpression)*)? (':' (logicalOrExpression (',' logicalOrExpression)*)?)* ')' ';' ; 赋值语句赋值语句，语法成分为，有两种类型 条件表达式，因为用多元运算符也可以对变量进行赋值操作 一元表达式+赋值运算符+赋值语句 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 赋值语句assignmentExpression : conditionalExpression | unaryExpression assignmentOperator assignmentExpression ;// 赋值运算符assignmentOperator : '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '&lt;&lt;=' | '&gt;&gt;=' | '&amp;=' | '^=' | '|=' ;// 判断语句conditionalExpression : logicalOrExpression ('?' expression ':' conditionalExpression)? ;// 逻辑语句logicalAndExpression : inclusiveOrExpression | logicalAndExpression '&amp;&amp;' inclusiveOrExpression ;logicalOrExpression : logicalAndExpression | logicalOrExpression '||' logicalAndExpression ;// 一元表达式unaryExpression : postfixExpression | '++' unaryExpression | '--' unaryExpression | unaryOperator castExpression | 'sizeof' unaryExpression | 'sizeof' '(' typeName ')' | '_Alignof' '(' typeName ')' | '&amp;&amp;' Identifier // GCC extension address of label ;// 一元运算符unaryOperator : '&amp;' | '*' | '+' | '-' | '~' | '!' ;postfixExpression : primaryExpression | postfixExpression '[' expression ']' | postfixExpression '(' argumentExpressionList? ')' | postfixExpression '.' Identifier | postfixExpression '-&gt;' Identifier | postfixExpression '++' | postfixExpression '--' | '(' typeName ')' '{' initializerList '}' | '(' typeName ')' '{' initializerList ',' '}' | '__extension__' '(' typeName ')' '{' initializerList '}' | '__extension__' '(' typeName ')' '{' initializerList ',' '}' ; 表达式1234expression : assignmentExpression | expression ',' assignmentExpression ; 分支语句分支语句，语法成分为，有三种类型(ANTLR简写为两种) 关键字if开头，作为判断条件，然后是执行的结构体；如果只有有else关键字，则还有一个执行的结构体 关键字switch开头，作为判断条件，然后是执行的结构体 1234selectionStatement : 'if' '(' expression ')' statement ('else' statement)? | 'switch' '(' expression ')' statement ; 循环语句循环语句，语法成分为&lt; Iteration-statement&gt;，有四种类型 while：while关键字开头，其后为条件，为执行结构体 do-while：do关键字开头，其后为执行结构体，while关键字，其后为条件 for(;;) for(;) 123456iterationStatement : 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement ; 具体实验 心得体会 这次实验中，我难得有机会阅读了C语言的规范文件。对C语言的产生过程和前端的编译过程有了更深一步的认识，了解程序设计语言的演化过程和相关标准的制定过程，掌握文法的概念， 并能够使用文法对给定的语言进行描述； 同时这次实验也进一步了加深我对C语言语法的理解，了解了一些不常使用的库函数或者过程，比如C语言多线程执行的过程。C语言的文法规则体现了C语言及其设计者的严谨性。","link":"/posts/33846/"},{"title":"网络安全工程-实验2-密码学基础与实践","text":"truecrypt和bitlocker的使用 参考网址： http://truecrypt.sourceforge.net TrueCrypt工具使用 从该地址下载旧版TrueCrypt工具：http://soft.down9.xyz/TrueCrypt_5284.zip TrueCrypt官网上的软件都只能用于解密而不能用于创造保险箱。官网首页是Windows上的使用和下载。在页面最低部找到If you use TrueCrypt on other platform than Windows, clickhere 可进入Mac版使用指南。 Truecrypt工具虽然有Mac版本，但是安装时会有TrueCrypt requires Mac OS X 10.4 or later.的错误提示。实测10.15版本的Catalina是无法安装的。 Windows则要求Win7及以下的系统(win10会出建议使用BitLocker 的Warning， Linux系统会有和Windows一样的Warning。 The development of TrueCrypt was ended in 5/2014 after Microsoft terminated support of Windows XP. Windows 8/7/Vista and later offer integrated support for encrypted disks and virtual disk images. 下载后，以管理员身份运行.exe文件 逐步选择需要的属性 挂载加密卷，可以看到分配的盘符为O 改磁盘O即为文件保险箱。 BitLocker 右键选择要加密宗卷(F:)，点击BitLocker选项 按照需要选择加密的选项 加密完成后，所选磁盘出现🔐的图标，需要密码才能进入","link":"/posts/12800/"},{"title":"网络安全工程-实验1-Shodan","text":"Shodan 是一个搜索引擎 网络安全工程-Shodan https://www.shodan.io/ 初步体验摄像头检索 检索：JAWS，我尝试了多个结果，发现常用密码其实并不常用，但是密码为空是真的很常用 用户名：admin 密码：空 下载 其他： 关键词：JAWS / 地址：中国长春 / 密码：无 关键词：JAWS / 地址：澳大利亚罗泽尔 / 密码：无 关键词：Jaws / 地址：埃及 / 密码：无 使用webcam关键词得到的网址http://173.0.76.63:443/，指向色情网站。其盈利模式为会员制，内容核心是利用网络摄像头进行直播。其IP地址的keyword中出现webcam port使用port: 22搜索22号端口的主机信息，表明下面的主机开放了22号端口，对应SSH服务。 host搜索IP ADDRESS尝试搜索主机。这里我尝试了在DO购买的SFO主机，返回的信息中，地区有误 我又尝试了阿里云的香港主机，返回的信息中提示软件服务可能存在漏洞 感想 Shodan或许能做很多事。如果像我一样只是漫无目的的在里面乱逛的话，它其实仅仅是一个比较特别的搜索引擎 大多数监控摄像头都是没有设置密码的。我在尝试使用Server: Hikvision-Webs”的关键字时，发现这个摄像头的登录中设置了仅仅允许进行6次尝试。网络安全的保障是多方面共同努力的。网站的管理员一定要做好安全工作，密码复杂和验证、防火墙等都是必要的。尽管实际中我时常为了使用方便而关闭服务器的防火墙，把防护的信心全都放在服务器的提供商身上—-我错了，下次还敢。 在这次体验中，我体会到了虽然网络安全的攻防往来明面上面向网络，面向软件，面向计算机的，但其实其根本还是面向人。","link":"/posts/30293/"},{"title":"软件测试笔记","text":"北京理工大学 计算机 软件测试 笔记 1 软件测试基础1.1 软件测试 定义 ：在特定条件下运行系统或构件、观察或记录结果，对系统某个方面做出评价。分析某个软件项以发现现存和要求的条件之差别并评价此软件项的特性 1.2 软件缺陷 Bug 定义：缺陷是对软件产品预期属性的偏离现象。与产品说明书不符 分类 功能、特点没实现/部分实现 实际与预期不一致 运行出错：运行中断、系统崩溃、界面混乱 用户不能接受的其他问题：存取时间过长、界面不美观 缺陷修复成本 1.3 软件测试模型 瀑布测试模型 修复代价高 1.2 V模型 把测试和设计开发分开 测试分阶段 测试阶段之内可以并行 1.3 RUP迭代V模型 1.4 软件测试分类 静态测试：看文档 动态测试：运行软件 1.5 测试用例 定义：确定软件或某功能与预期一致的一系列条件的集合 作用： 输入 判定 复用（测试脚本） 形式 步骤列表等 1.6 软件测试流程 测试过程 软件配置、测试配置 1.7 软件测试验证和确认的关系 软件测试：设计符合需求，代码符合设计 软件确认：黑盒确认测试（用户来判断） 测试=验证+确认 1.8 软件测试原则 尽早并不断进行软件测试 早期bug占多数 早期修复成本低 程序员应该避免检查自己的程序 自己不会否认自己的算法 穷举测试不可能 输入情况不可能遍历 不可能证明一个程序的正确性 软件测试有风险 应当输入合理和不合理的条件 测试中的群集效应（28效应）：有缺陷的地方往往有更多缺陷 严格执行测试计划、排除随意性 应当对每一个测试结果做全面检查 1.9 软件测试中的误区 调试和测试是相同的 软件测试对象仅限于程序 软件测试仅需要测试人员，不需要开发人员 单元测试是开发人员进行的 好的软件质量是通过测试得到的 把不合格的开发人员安排做测试 关注于测试的执行而忽略设计 测试自动化是万能的 测试是为了证明软件的正确性 无法证明正确性 2 单元测试2.1基本概念 单元测试又称模块测试，是针对软件设计的最小单位-程序模块，进行正确性检验的测试工作 单元测试特点 单元测试主要需要测试者非常清楚代码内部结构，单元测试是软件开发人员的职责，==测试人员一般不参与单元测试== 既可以静态测试也可以动态测试 单元选择的依据 单元必须是可测试的 有明确规约（ground truth）作为测试依据 单元的行为或输出是可观测的 有一个明确的可定义的边界或接口 单元：能够实现需求规格的最小组件 函数、过程、类（面对对象语言单元测试均是以类为基准）、页面 单元测试的组织：谁写谁测 分级 的单元测试–产业 每个类对应一个testing-class 每个method对应一个或多个testing-method 单元测试的主要目的 合格代码的要求：正确性、清晰性、规范性、一致性、高效性 2.2单元测试方法 静态 白盒 动态 黑盒 2.4 静态测试 静态测试目标和内容 详细设计文档 代码风格和规则 程序设计和结构的检查 方法 同行评审：由软件工作产品创建者的同行们检查该工作产品，识别产品的缺陷，改进产品的不足 产品：最终产品的组成部分，源代码、设计文档 同行：项目成员和具有同等开发专业技能的并==熟知工件==的人员。也称为评省人员或评省组成员 公司内项目组成员 公司内其他项目组成员 公司外的专家 形式 走读（最自由） 评价软件代码（code review） 小组评省（做决策） 参与者主要是公司技术领导或权威及公司外部专家 ==需求规范和概要设计==的评审 目标：提出意见和建议 确认某个制品是否符合要求，能否进入下个阶段 如何提高制品的质量，如何使之符合要求 审查 组织：公司内部设计开发测试质量等部门中工作性质相关的员工（QA部门） 形式：它遵循一个严格的过程，人员经过培训，检查过程有标准 适用范围与目的 代码、详细设计、概要设计 形成缺陷列表，缺陷总结 流程：计划—评省实施（会议形式）—评省情况统计（形成文档）—问题追踪/修改 数据流测试（少见，程序员自己进行，不提倡） 2.4.1 静态测试-详细设计 测试依据：概要设计（总体设计） 主要形式：审查和走读 检查要求：清晰性、完整性、规范性、一致性、正确性、数据、可靠性(catch e)、可追溯性、==接口== 数据：数据都已经被描述 可追溯性：每个详细设计单元都可以追溯到概要设计 接口 2.4.2 代码静态测试 代码静态测试是开发者自己执行的数据流测试或同行执行的代码走读 代码走读测试 代码风格和规则检查 程序设计和结构的检查 模块接口的正确性检查 输入参数有没有做正确性检查 调用其他方法接口的正确性 出错处理是否能挣挣表示错误是什么 保证表达式、SQL语句的正确性 检查常量或全局变量的正确性 数字是否使用表示符 检查代码是否可以优化、算法效率是否最高 业务逻辑的检查 2.5 黑盒测试2.5.1 边界值测试 针对各种边界情况设计测试用例 最大值 最小值 略大于最大值 略小于最小值 中间值 变异： 主动植入错误，查看测试用例通过的数量 覆盖率 2.5.2 等价类划分测试 等价类：软件的行为对于一组值来说是相同的，那么这组值就叫做等价类 feajofj 测试用例选择 尽可能多地覆盖尚未覆盖的有效等价类，重复直到覆盖所有有效等价类 尽可能少地覆盖尚未被覆盖的无效等价类，重复直到所有无效等价类都被覆盖为止 有效等价类： 1、年龄20～39 2、年龄40～59 3、年龄：60岁以上20岁以下 4、性别：Female（F） 5、性别：Male（M） 6、 婚姻：Married 7、婚姻：Unmarried 9、抚养人数：0 10、抚养人数：1～6 11、抚养人数：6人以上 Order Age Gender Marriage 抚养人数 保险费率 testcase1（覆盖等价类1 4 7 9） 25 Female Unmarried 0 0.6% testcase2（覆盖等价类2 5 6 10） 50 Male Married 3 0.6% testcase3（覆盖等价类3 4 6 11） 70 Female Married 7 1% testcase4（年龄无效） 0 Male Unmarried 4 null testcase5（性别无效） 35 Unknown Married 0 null testcase6（婚姻无效） 28 Male Unknown 3 null testcase7（抚养人数无效） 29 Male Married -1 null 年月日 2019年12月5日 有效等价类 年 2017年之前 2017年-2019年 2019年之后 月 1 3 5 7 8 10 12月 2月 4 6 9 11月 日 1～28 29 30 31 Order 年 月 日 结果 testcase1（覆盖等价类1.1 2.1 3.1） 2016 1 1 超出范围 testcase2（覆盖等价类1.2 2.2 3.2） 2018 2 29 不存在这一天 testcase3（覆盖等价类1.3 2.3 3.3） 2020 4 30 超出查询范围 testcase4（覆盖等价类1.2 2.3 3.4） 2017 6 31 不存在这一天 testcase5（年份无效） 0 6 1 输入违法 testcase6（月份无效） 2018 13 5 输入违法 testcase7（日期无效） 2018 3 0 输入违法 2.5.3 输入组合法测试（不考） 研究统计表明：很多程序的错误都是由少数几个参数及参数之间的相互作用而导致 基本思想：统计学的角度对测试实验进行设计 求解配对测试用例的方法：正交表 选的点都不在一个线上（共同的坐标值超过1个） 任意两个平面必须有共同点（交点） 不同取值个数的处理方法 补齐 2.5.4 因果图法（必考） 是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，适合于检查程序输入条件的各种组合情况 首先从程序规格说明书的描述中，找出因（输入条件）和果（输出结果或程序状态的改变） 将因果图转换为判定表，判定表每一列设计一个测试用例 通常Ci表示原因，Ei表示结果，各节点表示状态，可取值0，1。0表示状态不出现，1表示状态出现 恒等：原因结果同时出现 若c1是1，则e1也是1；否则e1为0. 非~：原因出现，结果不出现；原因不出现，结果出现 若c1是1，则e1是0；否则e1 是1； 或V：原因只有一个出现，结果就出现；原因都不出现，结果就不出现。 若c1或c2或c3是1，则e1是1；否则e1为0。“或”可有任意个输入 且/与^：原因都出现，结果才出现。 若c1和c2都是1，则e1为1；否则e1为0。可有任意个输入 约束条件 从输入考虑 E exclusive 互斥：表示a，b两原因不会同时成立，最多一个能成立 I inclusive disjunction ：a、b、c三个原因中至少有一个必须成立 O（唯一）：a、b当中必须有一个，且仅有一个成立 R（要求）：当a出现时，b必须也出现，不可能a出现b不出现； 从输出考虑M（强制或屏蔽） 1）结果a是1时，结果b必须是0； 2）结果a是0时，结果b的值不定； 2.6 ==白盒测试== 知道源码，根据源码设计测试用例 黑盒：只能根据输入输出关系设计测试用例 基于数据的分类 白盒：根据内部结构优化测试用例的设计 测试的根源：不可能遍历所有的输入情况 2.6.1 覆盖率测试 语句覆盖 选取足够多的测试数据，使被测试程序中每个语句至少执行一次 控制流图，标号 判定覆盖（分支覆盖） 选取足够多的测试数据，使被测试程序中不仅每个语句至少执行一次，而且每个判定的每种可能的结果都至少执行一次 判定：程序分支节点上控制 条件覆盖：判定表达式中的每个条件都取到各种可能的结果（T&amp;&amp;F） 判定/条件覆盖： 选取足够多的测试数据，是被测试程序中每个判定表达式中的每个条件都取到各种可能的结果 A = 2, B = 1, X = 2 X = 2 1假2假3真4真 A = 1, B = 0, X = 0 X = 0 1真2真3假4假 ==（白盒的测试用例一般是自动生成的）== 条件组合覆盖 选取足够多的测试数据，使得判定表达式中条件的各种可能组合都至少出现一次 不需要跨条件组合 路径覆盖 选取足够多的测试数据，使得程序的每条可能路径都至少执行一次 路径：开始语句到结束语句之间执行的语句序列 满足条件组合不一定满足路径，满足路径不一定满足条件组合 2.6.2 循环测试 简单循环测试： 整个跳过循环 只有一次通过循环 两次通过循环 最大次数次通过循环 嵌套循环的测试集 把外循环设置为最小值并执行内循环的所有可能情况 把外循环设置为最大值并执行内循环的所有可能情况 把内循环设置为最小值并执行外循环的所有可能情况 把内循环设置为最大值并执行外循环的所有可能情况 2.6.4 程序切片测试 找出可能影响变量的语句的集合（应该包含语句本身） 2.6.6 基本路径测试 基本路径：程序中的循环体只执行零次和一次的路径就是基本路径 测试方法：只覆盖所有基本路径的测试方法 2.6.7 错误定位 可疑变量查看 可疑语句查看 函数调用语句 判定转移/循环语句 SQL语句 复杂算法段 插装：在软件特定的位置插入一些语句，用来获取软件的运行信息并反馈给测试者 2.7 灰盒测试2.8 白盒测试与黑盒测试的比较 白盒测试的优缺点 优点 揭示隐藏在代码中的错误 对代码的测试比较彻底 优化代码 缺点：昂贵 黑盒测试的优缺点 优点 对于较大的代码单元，效率高 测试人员不需要了解实现的细节 测试人员和编码人员相对独立 从用户的视角进行测试，容易被理解 有助于暴露任何规格不一致或有歧义的问题 测试用例可以在规格完成之后马上进行 缺点 只有一小部分可能的输入被测试到 如果没有清晰和简明的规格，测试用例难以设计 2.9 类测试2.10 单元测试流程2.11 单元测试角色和职责3 集成测试3.1 基本定义 集成测试又称组装测试，是在单元测试的基础上，将所有模块按照设计要求 3.1.1 集成测试和单元测试的区别 对象不同：集成测试组装的对象比单元测试的对象级别药膏 关注点区别：集成测试关注的是模块间的接口，接口间的数据传递关系，单元组合后是否实现预计的功能","link":"/posts/46157/"},{"title":"计算机网络-exp1-分层的协议栈体系结构","text":"wireshark抓包实验 计算机网络实验1-分层的协议栈体系结构实验目的分层的网络协议体系结构是网络的核心概念，本实验的目的是在学习掌握网络协议分析器工具的基础上，借助网络协议分析器学习在数据包中如何表示协议和分层。 实验工具 Wireshark - Version 3.2.1 (v3.2.1-0-gbf38a67724d0) curl 实验步骤 加深对网络协议的理解通常可以通过观察协议的运行和不断调试协议完成，观察两个 协议实体之间交换的报文序列，深入了解协议操作的细节，执行某些动作，然后观察这些动作产生的结果。 在第一个 Wireshark 实验中，让我们熟悉 Wireshark，做一些简单的抓包和观察。 1 捕获数据包 本步骤用你的计算机从 Web 服务器获取一个 URL，捕获这次 HTTP 通信的数据包并 观察协议数据包结构。 打开Capture-option菜单，选择接口，设置过滤器为tcp port 80, 选择选项页面下的“解析网络名字”复选框；取消复选框 “混杂” 打开终端，运行wget www.baidu.com, 获取成功后返回Wireshark 检查捕获的数据包 运行命令curl www.baidu.com，对应的过滤结果： 查看其中的GET数据包 GET包分为四个部分，分别是Ethernet，IPV4，TCP和 HTTP，数据帧4，数据链路层的source是本机的MAC地址，destination是路由器的地址 数据包结构 IPV4中的Dst 是百度的IPV4地址，从TCP中可以看出源端口为53883，目的端口为80，打开下方的HTTP协议 可以看到具体的内容，访问方式为GET，HOST为www.baidu.com，用户代理为curl，配合 下方的详细信息可以看出一个包的头部的封装结构，协议栈是自底向上组织的，头部的结构也是和协议栈的 顺序相同，各层数据包的嵌套关系图如下： 协议开销 使用命令wget https://annewqx.top/gallery/thumbnails/caddy.png，设置捕获选项为tcp port 443 监听结果 1~3为TCP/IP三次握手，和服务端建立连接 4是Get类型的HTTP请求；之后是数个TCP包； 71是HTTP，带着图片信息，其详细信息展示图片共51480bytes，由38个总长度为51935bytes的数据帧组成；效率99.12%，开销较小 复用/分用键字段 Ethernet的复用/分用键为首部末尾的2个字节，上层协议为IP(IPv4)时为08 00，IPv6为86 dd IP的复用/分用键为首部的第10个字节，为06","link":"/posts/23959/"}],"tags":[{"name":"course","slug":"course","link":"/tags/course/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"os","slug":"os","link":"/tags/os/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"VPS","slug":"VPS","link":"/tags/VPS/"},{"name":"科学上网","slug":"科学上网","link":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"caddy","slug":"caddy","link":"/tags/caddy/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"anaconda","slug":"anaconda","link":"/tags/anaconda/"},{"name":"haskell","slug":"haskell","link":"/tags/haskell/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"md","slug":"md","link":"/tags/md/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"compilation","slug":"compilation","link":"/tags/compilation/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"testing","slug":"testing","link":"/tags/testing/"},{"name":"network","slug":"network","link":"/tags/network/"}],"categories":[{"name":"code","slug":"code","link":"/categories/code/"},{"name":"guide","slug":"code/guide","link":"/categories/code/guide/"},{"name":"course","slug":"code/course","link":"/categories/code/course/"},{"name":"note","slug":"code/note","link":"/categories/code/note/"},{"name":"life","slug":"life","link":"/categories/life/"},{"name":"report","slug":"code/report","link":"/categories/code/report/"},{"name":"fragments","slug":"life/fragments","link":"/categories/life/fragments/"}]}